<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>The Cloistered Monkey (Posts about networking)</title><link>https://necromuralist.github.io/</link><description></description><atom:link href="https://necromuralist.github.io/categories/networking.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents © 2020 &lt;a href="mailto:necromuralist@protonmail.com"&gt;Cloistered Monkey&lt;/a&gt; </copyright><lastBuildDate>Sun, 08 Nov 2020 21:07:24 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>The Linux IPv6 Router Advertisement Daemon (radvd)</title><link>https://necromuralist.github.io/posts/the-linux-ipv6-router-advertisement-daemon-radvd/</link><dc:creator>Cloistered Monkey</dc:creator><description>&lt;div id="outline-container-orgb56fff9" class="outline-2"&gt;
&lt;h2 id="orgb56fff9"&gt;Background&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgb56fff9"&gt;
&lt;p&gt;
&lt;a href="http://www.litech.org/radvd/"&gt;radvd&lt;/a&gt; (the router advertisement daemon) sends IPv6 advertisements and responds to node IPv6 requests. Here's the description from the man page.
&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;
&lt;b&gt;radvd&lt;/b&gt; is the router advertisement daemon for IPv6. It listens to router solicitations and sends router advertisements as described in "Neighbor Discovery for IP Version 6 (IPv6)" (RFC 4861). With these advertisements hosts can automatically configure their addresses and some other parameters. They also can choose a default router based on these advertisements. 
&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org1baa0a3" class="outline-2"&gt;
&lt;h2 id="org1baa0a3"&gt;Installation and Setup&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org1baa0a3"&gt;
&lt;p&gt;
Setting &lt;b&gt;radvd&lt;/b&gt; is suspiciously easy compared to other linux services. First you install it.
&lt;/p&gt;

&lt;pre class="example"&gt;
sudo apt install radvd
&lt;/pre&gt;

&lt;p&gt;
Installing it will also start the service so we can use &lt;code&gt;systemctl&lt;/code&gt; to check how it's doing.
&lt;/p&gt;

&lt;pre class="example"&gt;
systemctl status radvd
&lt;/pre&gt;

&lt;pre class="example"&gt;
systemctl status radvd
● radvd.service - LSB: Router Advertising Daemon
   Loaded: loaded (/etc/init.d/radvd; bad; vendor preset: enabled)
   Active: active (exited) since Fri 2018-07-20 12:39:19 PDT; 36s ago
     Docs: man:systemd-sysv-generator(8)

Jul 20 12:39:18 asgaard systemd[1]: Starting LSB: Router Advertising Daemon...
Jul 20 12:39:19 asgaard radvd[8532]: Starting radvd:
Jul 20 12:39:19 asgaard radvd[8532]: * /etc/radvd.conf does not exist or is empty.
Jul 20 12:39:19 asgaard radvd[8532]: * See /usr/share/doc/radvd/README.Debian
Jul 20 12:39:19 asgaard radvd[8532]: * radvd will *not* be started.
Jul 20 12:39:19 asgaard systemd[1]: Started LSB: Router Advertising Daemon.
&lt;/pre&gt;

&lt;p&gt;
You can see in the output that there's a line with &lt;code&gt;/etc/radvd.conf does not exist or is empty.&lt;/code&gt;. To fix this we're going to create the configuration file.
&lt;/p&gt;
&lt;/div&gt;

&lt;div id="outline-container-org44af890" class="outline-3"&gt;
&lt;h3 id="org44af890"&gt;The Configuration File&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org44af890"&gt;
&lt;p&gt;
Now create a configuration file (named &lt;code&gt;radvd.conf&lt;/code&gt;). Here's an example.
&lt;/p&gt;

&lt;pre class="example"&gt;
interface eth0
{
MinRtrAdvInterval 3;
MaxRtrAdvInterval 4;
AdvSendAdvert on;
AdvManagedFlag on;
prefix 2001:db7::/64
{ AdvValidLifetime 14300; AdvPreferredLifetime 14200; }
;
};
&lt;/pre&gt;

&lt;p&gt;
Note that the interface name depends on your system. Most linux systems don't use the &lt;code&gt;eth0&lt;/code&gt; convention anymore. On my desktop the ethernet inteface is called &lt;code&gt;enp1s0&lt;/code&gt; and on my raspberry pi it's &lt;code&gt;enxb827eb6c9129&lt;/code&gt; so make sure you check what your interface name is using &lt;code&gt;ifconfig&lt;/code&gt;.
&lt;/p&gt;

&lt;p&gt;
Now move (or copy) the config file into &lt;code&gt;/etc/&lt;/code&gt;
&lt;/p&gt;

&lt;pre class="example"&gt;
sudo mv radvd.conf /etc/
&lt;/pre&gt;

&lt;p&gt;
And then restart &lt;code&gt;radvd&lt;/code&gt; and check its state.
&lt;/p&gt;

&lt;pre class="example"&gt;
sudo service radvd restart
systemctl status radvd
&lt;/pre&gt;

&lt;pre class="example"&gt;
● radvd.service - LSB: Router Advertising Daemon
   Loaded: loaded (/etc/init.d/radvd; bad; vendor preset: enabled)
   Active: active (exited) since Fri 2018-07-20 12:41:36 PDT; 2s ago
     Docs: man:systemd-sysv-generator(8)
  Process: 10008 ExecStop=/etc/init.d/radvd stop (code=exited, status=0/SUCCESS)
  Process: 10017 ExecStart=/etc/init.d/radvd start (code=exited, status=0/SUCCESS)

Jul 20 12:41:36 asgaard systemd[1]: Starting LSB: Router Advertising Daemon...
Jul 20 12:41:36 asgaard radvd[10017]: Starting radvd:
Jul 20 12:41:36 asgaard radvd[10017]: * IPv6 forwarding seems to be disabled.
Jul 20 12:41:36 asgaard radvd[10017]: * See /usr/share/doc/radvd/README.Debian
Jul 20 12:41:36 asgaard radvd[10017]: * radvd will *not* be started.
Jul 20 12:41:36 asgaard systemd[1]: Started LSB: Router Advertising Daemon.
&lt;/pre&gt;

&lt;p&gt;
So the warning about the configuration file went away, now we have to fix the &lt;code&gt;IPv6 forwarding seems to be disabled.&lt;/code&gt; error.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org48af3a7" class="outline-3"&gt;
&lt;h3 id="org48af3a7"&gt;Enable IPv6 Forwarding&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org48af3a7"&gt;
&lt;p&gt;
For now you can enable it at the command line.
&lt;/p&gt;

&lt;pre class="example"&gt;
sudo sysctl -w net.ipv6.conf.all.forwarding=1
&lt;/pre&gt;

&lt;p&gt;
And restart and check &lt;code&gt;radvd&lt;/code&gt; again.
&lt;/p&gt;

&lt;pre class="example"&gt;
sudo service radvd restart
systemctl status radvd
&lt;/pre&gt;

&lt;pre class="example"&gt;
● radvd.service - LSB: Router Advertising Daemon
   Loaded: loaded (/etc/init.d/radvd; bad; vendor preset: enabled)
   Active: active (running) since Fri 2018-07-20 12:45:02 PDT; 20s ago
     Docs: man:systemd-sysv-generator(8)
  Process: 12255 ExecStop=/etc/init.d/radvd stop (code=exited, status=0/SUCCESS)
  Process: 12264 ExecStart=/etc/init.d/radvd start (code=exited, status=0/SUCCESS)
   CGroup: /system.slice/radvd.service
           ├─12275 /usr/sbin/radvd -u radvd -p /var/run/radvd/radvd.pid
           └─12276 /usr/sbin/radvd -u radvd -p /var/run/radvd/radvd.pid

Jul 20 12:45:01 asgaard systemd[1]: Starting LSB: Router Advertising Daemon...
Jul 20 12:45:02 asgaard radvd[12274]: version 2.11 started
Jul 20 12:45:02 asgaard radvd[12264]: Starting radvd: radvd.
Jul 20 12:45:02 asgaard systemd[1]: Started LSB: Router Advertising Daemon.
&lt;/pre&gt;

&lt;p&gt;
So it looks like our daemon is working. If you restart the server, though, the IPv6 port forwarding won't be enabled so open up &lt;code&gt;/etc/sysctl.conf&lt;/code&gt; and un-comment out the following line.
&lt;/p&gt;

&lt;pre class="example"&gt;
net.ipv6.conf.all.forwarding=1
&lt;/pre&gt;

&lt;p&gt;
Now the next time you power on the computer it should be enabled.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org932e933" class="outline-2"&gt;
&lt;h2 id="org932e933"&gt;Checking&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org932e933"&gt;
&lt;p&gt;
To check if it's working you can put another device on the LAN and check &lt;code&gt;ifconfig&lt;/code&gt;. In our &lt;code&gt;radvd.conf&lt;/code&gt; file we defined the prefix for the address:
&lt;/p&gt;

&lt;pre class="example"&gt;
prefix 2001:db7::/64
&lt;/pre&gt;

&lt;p&gt;
So in the &lt;code&gt;ifconfig&lt;/code&gt; output  we should see an entry for an IPv6 address that starts with &lt;code&gt;2001:db7::&lt;/code&gt;. In fact I ended up with two.
&lt;/p&gt;

&lt;pre class="example"&gt;
inet6 2001:db7::b8b4:6adf:6267:5571  prefixlen 64  scopeid 0x0&amp;lt;global&amp;gt;
inet6 2001:db7::a80c:1a05:eaac:c1e8  prefixlen 64  scopeid 0x0&amp;lt;global&amp;gt;
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org2744825" class="outline-2"&gt;
&lt;h2 id="org2744825"&gt;Sources&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org2744825"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;a href="https://www.linux.com/learn/intro-to-linux/2017/12/ipv6-auto-configuration-linux"&gt;IPv6 auto-configuration&lt;/a&gt; - how to setup &lt;b&gt;radvd&lt;/b&gt; (from linux.com)&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>how-to</category><category>networking</category><guid>https://necromuralist.github.io/posts/the-linux-ipv6-router-advertisement-daemon-radvd/</guid><pubDate>Fri, 20 Jul 2018 18:12:11 GMT</pubDate></item><item><title>Networking Tools</title><link>https://necromuralist.github.io/posts/networking-tools/</link><dc:creator>Cloistered Monkey</dc:creator><description>&lt;div id="outline-container-org2b85a7e" class="outline-2"&gt;
&lt;h2 id="org2b85a7e"&gt;Packet Capturing&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org2b85a7e"&gt;
&lt;/div&gt;
&lt;div id="outline-container-org840cf68" class="outline-3"&gt;
&lt;h3 id="org840cf68"&gt;&lt;a href="http://staff.washington.edu/corey/gulp/"&gt;Gulp&lt;/a&gt;&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org840cf68"&gt;
&lt;p&gt;
Gulp purports to be better at capturing packets than tcpdump (although they can work together).
&lt;/p&gt;

&lt;p&gt;
There is more than one version out there:
&lt;/p&gt;

&lt;p&gt;
-&lt;a href="//github.com/gsson/gulp"&gt; This one&lt;/a&gt; says it applied a patch to it five years ago. 
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;a href="https://github.com/aokunev/gulp-v01"&gt;This one&lt;/a&gt; says it is the original but hasn't been updated in six years.&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.crox.net/archives/72-gulp-tcpdump-alternative-for-lossless-capture-on-Linux.html"&gt;This blog post&lt;/a&gt; has updated versions of it including one in 2017 that says it has a major bug fix (but I don't know if it's a gulp bug or not)&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org7d75699" class="outline-3"&gt;
&lt;h3 id="org7d75699"&gt;&lt;a href="https://www.tcpdump.org"&gt;tcpdump&lt;/a&gt;&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org7d75699"&gt;
&lt;p&gt;
More easily obtainable and better documentation available (although still not enough).
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgaaf30ab" class="outline-3"&gt;
&lt;h3 id="orgaaf30ab"&gt;&lt;a href="http://ssldump.sourceforge.net"&gt;ssldump&lt;/a&gt;&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgaaf30ab"&gt;
&lt;p&gt;
Captures packets and decodes SSL/TLS packets.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org571d666" class="outline-2"&gt;
&lt;h2 id="org571d666"&gt;Packet Examining&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org571d666"&gt;
&lt;/div&gt;
&lt;div id="outline-container-org6c86223" class="outline-3"&gt;
&lt;h3 id="org6c86223"&gt;&lt;a href="https://github.com/mschiffm/cppip"&gt;Compressed PCAP Packet Indexing Prograpm (cppip)&lt;/a&gt;&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org6c86223"&gt;
&lt;p&gt;
This adds indexing to &lt;a href="http://www.htslib.org/doc/bgzip.html"&gt;bgzip&lt;/a&gt; compressed LibPCAP files which then lets you extract them while the original files are still compressed.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org8ec2e42" class="outline-3"&gt;
&lt;h3 id="org8ec2e42"&gt;&lt;a href="https://linux.die.net/man/8/tcpslice"&gt;tcpslice&lt;/a&gt;&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org8ec2e42"&gt;
&lt;p&gt;
This lets you extract part of or combine files created by tcpdump when using file rotation.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orge6e0688" class="outline-3"&gt;
&lt;h3 id="orge6e0688"&gt;&lt;a href="https://github.com/jpr5/ngrep"&gt;ngrep&lt;/a&gt;&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orge6e0688"&gt;
&lt;p&gt;
Describes itself as like GNU grep but for packets.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org3b60925" class="outline-3"&gt;
&lt;h3 id="org3b60925"&gt;&lt;a href="https://github.com/signed0/pylibpcap"&gt;pylibpcap&lt;/a&gt;, &lt;a href="https://github.com/pynetwork/pypcap"&gt;pypcap&lt;/a&gt;&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org3b60925"&gt;
&lt;p&gt;
Python code to work with libpcap.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org8cb3834" class="outline-3"&gt;
&lt;h3 id="org8cb3834"&gt;WireShark&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org8cb3834"&gt;
&lt;p&gt;
These are installed when you install wireshark.
&lt;/p&gt;
&lt;/div&gt;
&lt;div id="outline-container-org8fc953d" class="outline-4"&gt;
&lt;h4 id="org8fc953d"&gt;&lt;a href="https://www.wireshark.org/docs/man-pages/tshark.html"&gt;tshark&lt;/a&gt;/&lt;a href="https://www.wireshark.org"&gt;wireshark&lt;/a&gt;&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org8fc953d"&gt;
&lt;p&gt;
Packet capturing and examining (better documented than most of the other programs)
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org118cbfa" class="outline-4"&gt;
&lt;h4 id="org118cbfa"&gt;&lt;a href="https://www.wireshark.org/docs/man-pages/reordercap.html"&gt;reordercap&lt;/a&gt;&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org118cbfa"&gt;
&lt;p&gt;
Reorders the packets by timestamp.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgeaf353a" class="outline-4"&gt;
&lt;h4 id="orgeaf353a"&gt;&lt;a href="https://www.wireshark.org/docs/man-pages/capinfos.html"&gt;capinfos&lt;/a&gt;&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-orgeaf353a"&gt;
&lt;p&gt;
This prints summary information about packe files (works with gzipped files).
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org96b2c76" class="outline-4"&gt;
&lt;h4 id="org96b2c76"&gt;&lt;a href="https://www.wireshark.org/docs/man-pages/mergecap.html"&gt;mergecap&lt;/a&gt;&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org96b2c76"&gt;
&lt;p&gt;
Merges multiple packet files together. Mergecap will try to keep timestamps in order when merging, but it assumes each individual file to merge is already in order.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgb662d34" class="outline-2"&gt;
&lt;h2 id="orgb662d34"&gt;Packet Flows&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgb662d34"&gt;
&lt;/div&gt;
&lt;div id="outline-container-org1988692" class="outline-3"&gt;
&lt;h3 id="org1988692"&gt;&lt;a href="http://tcpick.sourceforge.net"&gt;tcpick&lt;/a&gt;&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org1988692"&gt;
&lt;p&gt;
Track, reassemble, reorder TCP streams.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org397ac31" class="outline-3"&gt;
&lt;h3 id="org397ac31"&gt;&lt;a href="http://www.tcptrace.org"&gt;tcptrace&lt;/a&gt;&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org397ac31"&gt;
&lt;p&gt;
Gives connection information taken from a capture file.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org0dae45a" class="outline-3"&gt;
&lt;h3 id="org0dae45a"&gt;&lt;a href="https://github.com/simsong/tcpflow"&gt;tcpflow&lt;/a&gt;&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org0dae45a"&gt;
&lt;p&gt;
Separates out TCP flows into separate files.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgdb34961" class="outline-2"&gt;
&lt;h2 id="orgdb34961"&gt;Capture Summarizing&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgdb34961"&gt;
&lt;/div&gt;
&lt;div id="outline-container-org1aa7ee3" class="outline-3"&gt;
&lt;h3 id="org1aa7ee3"&gt;&lt;a href="https://www.wireshark.org/docs/man-pages/capinfos.html"&gt;capinfos&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div id="outline-container-orge7f613e" class="outline-3"&gt;
&lt;h3 id="orge7f613e"&gt;&lt;a href="https://github.com/kohler/ipsumdump"&gt;ipsumdump&lt;/a&gt;&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orge7f613e"&gt;
&lt;p&gt;
Summarizes packet information in ASCII format
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgf003e79" class="outline-3"&gt;
&lt;h3 id="orgf003e79"&gt;&lt;a href="http://www.draconyx.net/articles/tcpdstat-fixing-a-compilation-bug-and-using-statistics.html"&gt;tcpdstat&lt;/a&gt;&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgf003e79"&gt;
&lt;p&gt;
Gives summary statistics for a pcap file
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org92db534" class="outline-2"&gt;
&lt;h2 id="org92db534"&gt;Network Monitoring&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org92db534"&gt;
&lt;/div&gt;
&lt;div id="outline-container-org339e51c" class="outline-3"&gt;
&lt;h3 id="org339e51c"&gt;&lt;a href="https://www.ntop.org"&gt;ntop&lt;/a&gt;&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org339e51c"&gt;
&lt;p&gt;
Like top but for the network.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org853be4b" class="outline-3"&gt;
&lt;h3 id="org853be4b"&gt;&lt;a href="http://man7.org/linux/man-pages/man8/ss.8.html"&gt;ss (socket statistics)&lt;/a&gt;&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org853be4b"&gt;
&lt;p&gt;
Part of &lt;a href="https://en.wikipedia.org/wiki/Iproute2"&gt;iproute2&lt;/a&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org1516a3e" class="outline-2"&gt;
&lt;h2 id="org1516a3e"&gt;Miscellaneous&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org1516a3e"&gt;
&lt;/div&gt;
&lt;div id="outline-container-org95916ce" class="outline-3"&gt;
&lt;h3 id="org95916ce"&gt;&lt;a href="http://tcpreplay.appneta.com/"&gt;tcpreplay&lt;/a&gt;&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org95916ce"&gt;
&lt;p&gt;
A suite of programs to edit and replay pcap files.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org8fafde9" class="outline-3"&gt;
&lt;h3 id="org8fafde9"&gt;&lt;a href="https://en.wikipedia.org/wiki/Netcat"&gt;netcat&lt;/a&gt;&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org8fafde9"&gt;
&lt;p&gt;
Read from and write to TCP/UDP network connections.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org1bddb0d" class="outline-3"&gt;
&lt;h3 id="org1bddb0d"&gt;&lt;a href="https://linux.die.net/man/1/socat"&gt;socat&lt;/a&gt;&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org1bddb0d"&gt;
&lt;p&gt;
Route data between byte streams.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>networking</category><category>tools</category><category>wireless</category><guid>https://necromuralist.github.io/posts/networking-tools/</guid><pubDate>Tue, 22 May 2018 20:57:42 GMT</pubDate></item><item><title>TCP Dump Notes</title><link>https://necromuralist.github.io/posts/tcp-dump-notes/</link><dc:creator>Cloistered Monkey</dc:creator><description>&lt;p&gt;
These are notes I made while surfing the web looking into &lt;a href="http://www.tcpdump.org/"&gt;TCP Dump&lt;/a&gt;. You will most likely need to use &lt;code&gt;sudo&lt;/code&gt; to run most of the commands, but I'm leaving it off to make it shorter.
&lt;/p&gt;

&lt;div id="outline-container-org325388d" class="outline-2"&gt;
&lt;h2 id="org325388d"&gt;About TCP Dump&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org325388d"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;It has more filtering capabilities and can filter while capturing packets, but it doesn't have the analytical tools that something like wireshark has&lt;sup&gt;&lt;a id="fnr.1" class="footref" href="https://necromuralist.github.io/posts/tcp-dump-notes/#fn.1"&gt;1&lt;/a&gt;&lt;/sup&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org343e174" class="outline-2"&gt;
&lt;h2 id="org343e174"&gt;Some Examples&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org343e174"&gt;
&lt;/div&gt;
&lt;div id="outline-container-org8d9658b" class="outline-3"&gt;
&lt;h3 id="org8d9658b"&gt;Listing interfaces&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org8d9658b"&gt;
&lt;p&gt;
You can ask &lt;code&gt;tcpdump&lt;/code&gt; which interfaces it is able to listen to&lt;sup&gt;&lt;a id="fnr.2" class="footref" href="https://necromuralist.github.io/posts/tcp-dump-notes/#fn.2"&gt;2&lt;/a&gt;&lt;/sup&gt;.
&lt;/p&gt;

&lt;pre class="example"&gt;
tcpdump -D
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgd54c20b" class="outline-3"&gt;
&lt;h3 id="orgd54c20b"&gt;Capture packets on an interface&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgd54c20b"&gt;
&lt;p&gt;
To capture packets on an interface you pass its name to the &lt;code&gt;-i&lt;/code&gt; flag&lt;sup&gt;&lt;a id="fnr.2.100" class="footref" href="https://necromuralist.github.io/posts/tcp-dump-notes/#fn.2"&gt;2&lt;/a&gt;&lt;/sup&gt; (here the interface I'll use is &lt;code&gt;eno1&lt;/code&gt;).
&lt;/p&gt;

&lt;pre class="example"&gt;
tcpdump -i eno1
&lt;/pre&gt;
&lt;/div&gt;

&lt;div id="outline-container-org6a12d03" class="outline-4"&gt;
&lt;h4 id="org6a12d03"&gt;Save the packet capture to a file&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org6a12d03"&gt;
&lt;p&gt;
The default behavior is for &lt;code&gt;tcpdump&lt;/code&gt; to send the output to standard output, to have it save the packets to a files use the &lt;code&gt;-w&lt;/code&gt; flag&lt;sup&gt;&lt;a id="fnr.2.100" class="footref" href="https://necromuralist.github.io/posts/tcp-dump-notes/#fn.2"&gt;2&lt;/a&gt;&lt;/sup&gt; (you can call it anything, I'll call it &lt;code&gt;dump.pcap&lt;/code&gt;).
&lt;/p&gt;

&lt;pre class="example"&gt;
tcpdump -i eno1 -w dump.pcap
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org888defd" class="outline-4"&gt;
&lt;h4 id="org888defd"&gt;Increase the verbosity of the capture&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org888defd"&gt;
&lt;p&gt;
To increase the amount if information that's captured, pass multiple &lt;code&gt;v&lt;/code&gt; arguments&lt;sup&gt;&lt;a id="fnr.2.100" class="footref" href="https://necromuralist.github.io/posts/tcp-dump-notes/#fn.2"&gt;2&lt;/a&gt;&lt;/sup&gt; (in this case I'll use &lt;code&gt;-vvv&lt;/code&gt;).
&lt;/p&gt;

&lt;pre class="example"&gt;
tcpdump -i eno1 -vvv -w dump.pcap
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org738b856" class="outline-3"&gt;
&lt;h3 id="org738b856"&gt;Filtering&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org738b856"&gt;
&lt;/div&gt;
&lt;div id="outline-container-org8d2887b" class="outline-4"&gt;
&lt;h4 id="org8d2887b"&gt;By IP address&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org8d2887b"&gt;
&lt;p&gt;
You can get all the packets being sent or received by a host using the &lt;code&gt;host&lt;/code&gt; argument&lt;sup&gt;&lt;a id="fnr.3" class="footref" href="https://necromuralist.github.io/posts/tcp-dump-notes/#fn.3"&gt;3&lt;/a&gt;&lt;/sup&gt;.
&lt;/p&gt;

&lt;pre class="example"&gt;
tcpdump host 192.168.1.12
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org7f79ee8" class="outline-4"&gt;
&lt;h4 id="org7f79ee8"&gt;By Sender IP Address&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org7f79ee8"&gt;
&lt;p&gt;
You can filter out all the packets except those that are being sent by a host using the &lt;code&gt;src host&lt;/code&gt; argument&lt;sup&gt;&lt;a id="fnr.2.100" class="footref" href="https://necromuralist.github.io/posts/tcp-dump-notes/#fn.2"&gt;2&lt;/a&gt;&lt;/sup&gt;.
&lt;/p&gt;

&lt;pre class="example"&gt;
tcpdump -i eno1 src host 192.168.1.12
&lt;/pre&gt;

&lt;p&gt;
You can leave off the &lt;code&gt;host&lt;/code&gt; argument and just use &lt;code&gt;src&lt;/code&gt;&lt;sup&gt;&lt;a id="fnr.3.100" class="footref" href="https://necromuralist.github.io/posts/tcp-dump-notes/#fn.3"&gt;3&lt;/a&gt;&lt;/sup&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org49810c5" class="outline-4"&gt;
&lt;h4 id="org49810c5"&gt;By Target IP Address&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org49810c5"&gt;
&lt;p&gt;
To filter out all the packets except those that are going to a specific target use the &lt;code&gt;dst host&lt;/code&gt; argument&lt;sup&gt;&lt;a id="fnr.2.100" class="footref" href="https://necromuralist.github.io/posts/tcp-dump-notes/#fn.2"&gt;2&lt;/a&gt;&lt;/sup&gt;.
&lt;/p&gt;

&lt;pre class="example"&gt;
tcpdump -i eno1 dst host 192.168.1.1
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org1f2a463" class="outline-4"&gt;
&lt;h4 id="org1f2a463"&gt;Sender and Target IP Addresses&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org1f2a463"&gt;
&lt;p&gt;
You can combine parameters using the logical operators &lt;code&gt;and&lt;/code&gt;, &lt;code&gt;or&lt;/code&gt;, and &lt;code&gt;not&lt;/code&gt;&lt;sup&gt;&lt;a id="fnr.3.100" class="footref" href="https://necromuralist.github.io/posts/tcp-dump-notes/#fn.3"&gt;3&lt;/a&gt;&lt;/sup&gt;.
&lt;/p&gt;

&lt;pre class="example"&gt;
tcpdump 'src 192.168.1.1 and dst 192.168.1.12'
&lt;/pre&gt;

&lt;p&gt;
The single quotes are optional and are just used to group the arguments together.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org4d67518" class="outline-4"&gt;
&lt;h4 id="org4d67518"&gt;By Subnet&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org4d67518"&gt;
&lt;p&gt;
You can grab all the packets on a network or subnet using the &lt;code&gt;net&lt;/code&gt; argument and &lt;a href="https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing#CIDR_notation"&gt;CIDR&lt;/a&gt; notation&lt;sup&gt;&lt;a id="fnr.3.100" class="footref" href="https://necromuralist.github.io/posts/tcp-dump-notes/#fn.3"&gt;3&lt;/a&gt;&lt;/sup&gt;. This example grabs all the packets on the &lt;code&gt;192.168.1.*&lt;/code&gt; subnet.
&lt;/p&gt;

&lt;pre class="example"&gt;
tcpdump net 192.168.1.0/24
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgba6546b" class="outline-4"&gt;
&lt;h4 id="orgba6546b"&gt;By port and/or protocol&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-orgba6546b"&gt;
&lt;p&gt;
If you want to only catch activity on a certain &lt;a href="https://en.wikipedia.org/wiki/Port_(computer_networking)"&gt;port&lt;/a&gt; and by a certain protocol then you use the &lt;code&gt;port&lt;/code&gt; argument and the name of the protocol (e.g. &lt;code&gt;udp&lt;/code&gt;)&lt;sup&gt;&lt;a id="fnr.3.100" class="footref" href="https://necromuralist.github.io/posts/tcp-dump-notes/#fn.3"&gt;3&lt;/a&gt;&lt;/sup&gt;. This would catch all the &lt;code&gt;tcp&lt;/code&gt; traffic over SSH.
&lt;/p&gt;
&lt;pre class="example"&gt;
tcpdump tcp port 22
&lt;/pre&gt;

&lt;p&gt;
You can use &lt;code&gt;tcp&lt;/code&gt;, &lt;code&gt;udp&lt;/code&gt;, or &lt;code&gt;icmp&lt;/code&gt; for the protocols and add multiple ports using a comma&lt;sup&gt;&lt;a id="fnr.4" class="footref" href="https://necromuralist.github.io/posts/tcp-dump-notes/#fn.4"&gt;4&lt;/a&gt;&lt;/sup&gt;.
&lt;/p&gt;

&lt;pre class="example"&gt;
tcpdump tcp port 22,80
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgbfbba74" class="outline-4"&gt;
&lt;h4 id="orgbfbba74"&gt;Turn off hostname and port translation&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-orgbfbba74"&gt;
&lt;p&gt;
The default behavior for &lt;code&gt;tcpdump&lt;/code&gt; is to translate the hostnames and ports to something human-readable if possible. To turn this off you pass in the &lt;code&gt;-n&lt;/code&gt; argument&lt;sup&gt;&lt;a id="fnr.3.100" class="footref" href="https://necromuralist.github.io/posts/tcp-dump-notes/#fn.3"&gt;3&lt;/a&gt;&lt;/sup&gt;. Since this stops having to look things up it will reduce the amount of overhead needed by &lt;code&gt;tcpdump&lt;/code&gt;.
&lt;/p&gt;

&lt;pre class="example"&gt;
tcpdump -n -i eno1 port 22
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org93a5a0e" class="outline-2"&gt;
&lt;h2 id="org93a5a0e"&gt;Links&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org93a5a0e"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;(Wireshark Revealed&lt;sup&gt;&lt;a id="fnr.5" class="footref" href="https://necromuralist.github.io/posts/tcp-dump-notes/#fn.5"&gt;5&lt;/a&gt;&lt;/sup&gt;) &lt;a href="http://www.tcpdump.org/"&gt;The tcpdump website&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;(Wireshark Revealed&lt;sup&gt;&lt;a id="fnr.5.100" class="footref" href="https://necromuralist.github.io/posts/tcp-dump-notes/#fn.5"&gt;5&lt;/a&gt;&lt;/sup&gt;) &lt;a href="http://danielmiessler.com/study/tcpdump/"&gt;A friendly tutorial&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;(Wireshark Revealed&lt;sup&gt;&lt;a id="fnr.5.100" class="footref" href="https://necromuralist.github.io/posts/tcp-dump-notes/#fn.5"&gt;5&lt;/a&gt;&lt;/sup&gt;) &lt;a href="http://www.tcpdump.org/tcpdump_man.html"&gt;The official man page&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgf602d42" class="outline-2"&gt;
&lt;h2 id="orgf602d42"&gt;Sources&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgf602d42"&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="footnotes"&gt;
&lt;h2 class="footnotes"&gt;Footnotes: &lt;/h2&gt;
&lt;div id="text-footnotes"&gt;

&lt;div class="footdef"&gt;&lt;sup&gt;&lt;a id="fn.1" class="footnum" href="https://necromuralist.github.io/posts/tcp-dump-notes/#fnr.1"&gt;1&lt;/a&gt;&lt;/sup&gt; &lt;div class="footpara"&gt;&lt;p class="footpara"&gt;
Diogenes, Y. &amp;amp; Ozkaya, E. (2018). Cybersecurity, Attack and Defense Strategies : infrastructure security with Red Team and Blue Team tactics. Birmingham, UK: Packt Publishing.]
&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class="footdef"&gt;&lt;sup&gt;&lt;a id="fn.2" class="footnum" href="https://necromuralist.github.io/posts/tcp-dump-notes/#fnr.2"&gt;2&lt;/a&gt;&lt;/sup&gt; &lt;div class="footpara"&gt;&lt;p class="footpara"&gt;
Johansen, G. (2017). Digital forensics and incident response : an intelligent way to respond to attacks. Birmingham, UK: Packt Publishing.
&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class="footdef"&gt;&lt;sup&gt;&lt;a id="fn.3" class="footnum" href="https://necromuralist.github.io/posts/tcp-dump-notes/#fnr.3"&gt;3&lt;/a&gt;&lt;/sup&gt; &lt;div class="footpara"&gt;&lt;p class="footpara"&gt;
Beltrame, J. (2017). Penetration testing bootcamp : quickly get up and running with pentesting techniques. Birmingham, UK: Packt Publishing.
&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class="footdef"&gt;&lt;sup&gt;&lt;a id="fn.4" class="footnum" href="https://necromuralist.github.io/posts/tcp-dump-notes/#fnr.4"&gt;4&lt;/a&gt;&lt;/sup&gt; &lt;div class="footpara"&gt;&lt;p class="footpara"&gt;
McPhee. &amp;amp; Beltrame, J. (2016). Penetration testing with Raspberry Pi : learn the art of building a low-cost, portable hacking arsenal using Raspberry Pi 3 and Kali Linux 2. Birmingham, UK: Packt Publishing.
&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class="footdef"&gt;&lt;sup&gt;&lt;a id="fn.5" class="footnum" href="https://necromuralist.github.io/posts/tcp-dump-notes/#fnr.5"&gt;5&lt;/a&gt;&lt;/sup&gt; &lt;div class="footpara"&gt;&lt;p class="footpara"&gt;
Baxter, J., Orzach, Y. &amp;amp; Mishra, C. (2017). Wireshark revealed : essential skills for IT professionals : get up and running with Wireshark to analyze your network effectively. Birmingham, UK: Packt Publishing.
&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;


&lt;/div&gt;
&lt;/div&gt;</description><category>networking</category><category>notes</category><guid>https://necromuralist.github.io/posts/tcp-dump-notes/</guid><pubDate>Wed, 09 May 2018 21:54:56 GMT</pubDate></item><item><title>Tuning a TCP Connection</title><link>https://necromuralist.github.io/posts/201209tuning-tcp-connection/</link><dc:creator>Cloistered Monkey</dc:creator><description>&lt;div id="table-of-contents"&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id="text-table-of-contents"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/posts/201209tuning-tcp-connection/#org70e7545"&gt;TCP Background&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/posts/201209tuning-tcp-connection/#orga101a89"&gt;The TCP Congestion Window&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/posts/201209tuning-tcp-connection/#org0829d89"&gt;Optimal Buffer Size&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/posts/201209tuning-tcp-connection/#org04e1aea"&gt;Changing the Buffer Size&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/posts/201209tuning-tcp-connection/#org201da0c"&gt;Picking a Buffer Size&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/posts/201209tuning-tcp-connection/#org257d433"&gt;The Maximum Throughput&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/posts/201209tuning-tcp-connection/#org2b79b4c"&gt;Bandwidth Delay Product&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/posts/201209tuning-tcp-connection/#org121f7df"&gt;Iperf Tuning&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/posts/201209tuning-tcp-connection/#org4538866"&gt;Iperf Warnings&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/posts/201209tuning-tcp-connection/#orgf518dce"&gt;Parallel Streams&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/posts/201209tuning-tcp-connection/#orga012992"&gt;Maximum Transmission Unit (MTU)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
I wrote this a long time ago so I don't remember the source or really the intent. I think it was about trying to maximize the throughput when running iperf over TCP.
&lt;/p&gt;

&lt;div id="outline-container-org70e7545" class="outline-2"&gt;
&lt;h2 id="org70e7545"&gt;TCP Background&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org70e7545"&gt;
&lt;/div&gt;
&lt;div id="outline-container-orga101a89" class="outline-3"&gt;
&lt;h3 id="orga101a89"&gt;The TCP Congestion Window&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orga101a89"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;Larger window implies higher throughput&lt;/li&gt;
&lt;li&gt;The max allowed is based on the buffer space the kernel allocates for
each socket&lt;/li&gt;
&lt;li&gt;Each socket has a default buffer size&lt;/li&gt;
&lt;li&gt;Sender and receiver can both adjust the size&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org0829d89" class="outline-3"&gt;
&lt;h3 id="org0829d89"&gt;Optimal Buffer Size&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org0829d89"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;Too small - Sender will be throttled
&lt;ul class="org-ul"&gt;
&lt;li&gt;More likely if the Sender is faster than the receiver&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Too big - Receiver might be overloaded and packets will be dropped
&lt;ul class="org-ul"&gt;
&lt;li&gt;If the receiver has lots of memory, less likely to happen&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org04e1aea" class="outline-2"&gt;
&lt;h2 id="org04e1aea"&gt;Changing the Buffer Size&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org04e1aea"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;TCP chooses the smaller of both sides of the transaction.&lt;/li&gt;
&lt;li&gt;Set the receiver high and let the sender negotiate&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org201da0c" class="outline-2"&gt;
&lt;h2 id="org201da0c"&gt;Picking a Buffer Size&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org201da0c"&gt;
&lt;/div&gt;
&lt;div id="outline-container-org257d433" class="outline-3"&gt;
&lt;h3 id="org257d433"&gt;The Maximum Throughput&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org257d433"&gt;
&lt;p&gt;
If the network isn't congested the throughput is characterized by TCP buffer size and network latency.
&lt;/p&gt;

\begin{equation*} max \; throughput \gets \frac{buffer \; size}{latency}
\end{equation*}
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org2b79b4c" class="outline-3"&gt;
&lt;h3 id="org2b79b4c"&gt;Bandwidth Delay Product&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org2b79b4c"&gt;
&lt;p&gt;
This is a rule of thumb to calculate the optimal buffer size.
&lt;/p&gt;

\begin{equation*} bdp \gets bottleneck \; bandwidth \times round \; trip
\; time \end{equation*}

&lt;ul class="org-ul"&gt;
&lt;li&gt;Get the &lt;b&gt;rtt&lt;/b&gt; from &lt;b&gt;ping&lt;/b&gt;.&lt;/li&gt;
&lt;li&gt;Get &lt;b&gt;bottleneck bandwidth&lt;/b&gt; from the theoretical maximum rate of the slowest link.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org121f7df" class="outline-2"&gt;
&lt;h2 id="org121f7df"&gt;Iperf Tuning&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org121f7df"&gt;
&lt;/div&gt;
&lt;div id="outline-container-org4538866" class="outline-3"&gt;
&lt;h3 id="org4538866"&gt;Iperf Warnings&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org4538866"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;Iperf can set the buffer size up to a point – but the OS sets the
upper limit on window sizes.&lt;/li&gt;
&lt;li&gt;If the request is too high, iperf will use the maximum allowed and gives a warning.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgf518dce" class="outline-3"&gt;
&lt;h3 id="orgf518dce"&gt;Parallel Streams&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgf518dce"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;Iperf lets you run multiple parallel sessions using the -P flag.&lt;/li&gt;

&lt;li&gt;If the aggregate (SUM) is greater than a single stream, this is an indication that something is wrong – most likely one of:
&lt;ul class="org-ul"&gt;
&lt;li&gt;The TCP window is too small&lt;/li&gt;
&lt;li&gt;The OS implementation has bugs&lt;/li&gt;
&lt;li&gt;The network has problems&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orga012992" class="outline-3"&gt;
&lt;h3 id="orga012992"&gt;Maximum Transmission Unit (MTU)&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orga012992"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;the most effective way to set it is if both hosts support Path MTU Discovery and set it themselves.&lt;/li&gt;
&lt;li&gt;iperf's -m flag displays what mss is being used&lt;/li&gt;
&lt;li&gt;&lt;b&gt;mss&lt;/b&gt;: &lt;i&gt;Maximum Segment Size&lt;/i&gt; – the maximum TCP segment size&lt;/li&gt;
&lt;/ul&gt;

\begin{equation*} mss \gets MTU - protocol \; headers \end{equation*}

&lt;ul class="org-ul"&gt;
&lt;li&gt;Using -m is mainly to watch for the warning that the node lacks path mtu discovery&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>networking</category><category>optimization</category><guid>https://necromuralist.github.io/posts/201209tuning-tcp-connection/</guid><pubDate>Mon, 10 Sep 2012 06:51:00 GMT</pubDate></item></channel></rss>