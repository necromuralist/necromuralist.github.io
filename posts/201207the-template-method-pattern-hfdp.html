<html><body><div class="document" id="the-template-method-pattern-hfdp"><div class="section" id="what-is-the-template-method-pattern"><h4>What is the <em>Template Method Pattern</em>?</h4><ul class="simple"><li>Defines the skeleton of an algorithm in a method</li><li>Defers some steps to a subclass</li><li>Lets subclasses change some steps in the algorithm without changing the structure</li><li>The Template Method contains an ordered series of primitive operations -- by (re)defining the primitive operations, subclasses change the algorithm</li></ul></div><div class="section" id="what-are-hooks"><h4>What Are Hooks?</h4><ul class="simple"><li>A <em>Hook</em> is a method defined in the base class with a default or empty operation</li><li>Because it's not abstract, subclasses can ignore it</li><li>Because it's there, subclasses can re-define it without changing the structure of the template</li><li>If the hook returns a boolean for a conditional, it allows subclasses to change the flow of the algorithm</li></ul></div><div class="section" id="abstract-vs-hooks"><h4>Abstract Vs Hooks</h4><ul class="simple"><li><em>Abstract Methods</em> are requirements</li><li><em>Hooks</em> are optional</li></ul></div><div class="section" id="what-is-the-hollywood-principle"><h4>What Is the 'Hollywood Principle'?</h4><ul class="simple"><li><em>Don't call us, we'll call you</em>.</li><li>High-level components call low-level ones, not the other way around</li></ul></div><div class="section" id="strategy-vs-template"><h4>Strategy Vs Template</h4><ul class="simple"><li><em>Strategy</em> composes other objects chosen at runtime</li><li><em>Template</em> uses sub-classes</li><li><em>Template</em> provides better code re-use and strictly defines the algorithm</li><li><em>Strategy</em> provides better decoupling but the algorithm is provided by the composed objects</li></ul></div></div></body></html>