<html><body><div class="document" id="the-state-pattern-hfdp"><div class="section" id="what-is-the-state-pattern"><h4>What is the <em>State Pattern</em>?</h4><ul class="simple"><li>It allows an object to alter its behavior when the internal state changes</li><li>The object will appear to change its class</li></ul></div><div class="section" id="how-does-it-work"><h4>How Does It Work?</h4><ul class="simple"><li>A <cite>State</cite> interface is created that has all the actions the main class needs.</li><li>A concrete class is created for each state the system can be in (implementing the <cite>State</cite>)</li><li>Each state knows when a state change happens and sets the container's state class to the new state (object)</li><li>The container always calls state.method()</li><li>The states have to have a reference to the container since they changed its State</li></ul></div><div class="section" id="state-vs-strategy"><h4>State Vs Strategy</h4><ul class="simple"><li>User of context in state isn't aware of state objects</li><li>User of Strategy specifies objects to change the algorithm</li><li><em>Strategy</em> is a more flexible alternative to subclassing (changing the composition changes the behavior)</li><li><em>State</em> is an alternative to using conditionals</li></ul></div><div class="section" id="context-transitions-vs-state-transitions"><h4>Context Transitions Vs State Transitions</h4><ul><li><div class="first">You can decouple the states from the Context by having the Context choose the next state</div><blockquote><ul class="simple"><li>If Transitions are fixed, put in Context</li><li>If Transitions are dynamic, put in state (state knows the Transition to the next state)</li></ul></blockquote></li></ul></div><div class="section" id="do-states-maintain-state"><h4>Do States Maintain State?</h4><ul class="simple"><li>No, they choose Transitions</li><li>This means contexts can share the same strategies</li></ul></div></div></body></html>