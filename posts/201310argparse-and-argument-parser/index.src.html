<html><body><div class="document" id="argparse-and-the-argument-parser">   <p>Mocking the <a class="reference external" href="http://docs.python.org/2/library/argparse.html">argeparse ArgumentParser</a> might not seem like a necessary thing, since you can pass in a list of strings to fake the command-line arguments, but I ran into trouble trying to figure out how to test it embedded in one of my classes so I thought I would explore it anyway, out of curiosity if nothing else. I am primarily interested in mocking the calls to sys.argv to see how it works.</p><div class="section" id="sys-argv-calls"><h4>sys.argv Calls</h4><p>Using the <a class="reference external" href="http://www.voidspace.org.uk/python/mock/examples.html#tracking-order-of-calls-and-less-verbose-call-assertions">mock_calls</a> list from <tt class="docutils literal">mock</tt> can be useful in figuring out how an object is being used.</p><pre class="literal-block"><br>parser = argparse.ArgumentParser()<br>parser.add_argument('--debug', action='store_true')<br>parser.add_argument('-d')<br><br>sys = MagicMock()<br>with patch('sys.argv', sys):<br>    args = parser.parse_args()<br>for item in sys.mock_calls:<br>    print item<br>print args<br></pre><pre class="literal-block"><br>call.__getitem__(slice(1, None, None))<br>call.__getitem__().__iter__()<br>call.__getitem__().__getitem__(slice(0, None, None))<br>call.__getitem__().__getitem__().__iter__()<br>call.__getitem__().__getitem__().__len__()<br>Namespace(d=None, debug=False)<br></pre></div><div class="section" id="the-getitem-and-slice"><h4>The getitem and slice</h4><p>The first thing to note is the <a class="reference external" href="http://docs.python.org/2/reference/datamodel.html#object.__getitem__">__getitem__</a> calls. According to the documentation it is:</p><blockquote>Called to implement evaluation of self[key]. For sequence types, the accepted keys should be integers and slice objects.</blockquote><p>So it looks like it is first using the built-in <a class="reference external" href="http://docs.python.org/2/library/functions.html#slice">slice</a> function to get a particular argument. According to the documentation the arguments are the same as for the <tt class="docutils literal">range</tt> function (start, stop, step).</p><p>So it looks like it is doing the equivalent of <tt class="docutils literal">[1:]</tt> in the first slice:</p><pre class="literal-block"><br>test = [0,1,2]<br><br># what does it do?<br>print test.__getitem__(slice(1, None, None))<br><br># are they the same?<br>print test[1:] == test.__getitem__(slice(1, None, None))<br></pre><pre class="literal-block"><br>[1, 2]<br>True<br></pre><p>One thing to note is that <tt class="docutils literal">slice(1)</tt> is not the same thing as <tt class="docutils literal">slice(1, None, None)</tt>:</p><pre class="literal-block"><br>print slice(1)<br>print slice(1, None, None)<br></pre><pre class="literal-block"><br>slice(None, 1, None)<br>slice(1, None, None)<br></pre></div><div class="section" id="trying-a-lambda"><h4>Trying a lambda</h4><p>So, if I give <tt class="docutils literal">__getitem__</tt> a function to return the arguments I want, will this work?</p><pre class="literal-block"><br>sys.__getitem__ = lambda x,y: ['--debug']<br>with patch('sys.argv', sys):<br>    args = parser.parse_args()<br>for item in sys.mock_calls:<br>    print item<br><br>print args<br></pre><pre class="literal-block"><br>call.__getitem__(slice(1, None, None))<br>call.__getitem__().__iter__()<br>call.__getitem__().__getitem__(slice(0, None, None))<br>call.__getitem__().__getitem__().__iter__()<br>call.__getitem__().__getitem__().__len__()<br>Namespace(d=None, debug=True)<br></pre><p>It looks like it does, but would it be better to just make <tt class="docutils literal">argv</tt> a list?</p></div><div class="section" id="argv-as-a-list"><h4>argv as a list</h4><pre class="literal-block"><br>args = ['--debug']<br><br>def getitem(index):<br>    return args[index]<br><br># make a new mock since I set __getitem__ to a  lambda function<br>sys = MagicMock()<br>sys.__getitem__.side_effect = getitem<br><br>with patch('sys.argv', sys):<br>    parsed_args = parser.parse_args()<br><br>for item in sys.mock_calls:<br>    print item<br>print parsed_args<br></pre><pre class="literal-block"><br>call.__getitem__(slice(1, None, None))<br>Namespace(d=None, debug=False)<br></pre><p>It now does not make the other calls and it also does not set the <cite>debug</cite> to True, so it did not work.</p><p>But I seem to have forgotten my earlier slice check -- it is starting at the second item. I think that normally the name of the program is the first thing passed in so maybe there needs to be an extra (first) entry to simulate the command name.</p></div><div class="section" id="adding-a-command-name"><h4>Adding a Command Name</h4><pre class="literal-block"><br>args = 'commandname --debug'.split()<br><br>def getitem(index):<br>    return args[index]<br><br>sys.__getitem__.side_effect = getitem<br><br>with patch('sys.argv', sys):<br>    parsed_args = parser.parse_args()<br><br>for item in sys.mock_calls:<br>    print item<br>print parsed_args<br></pre><pre class="literal-block"><br>call.__getitem__(slice(1, None, None))<br>call.__getitem__(slice(1, None, None))<br>Namespace(d=None, debug=True)<br></pre><p>It looks like it worked, and all but the first two calls went away, so it perhaps they were a result of me using the mock, not a normal part of the way <cite>parse_args</cite> works.</p></div><div class="section" id="the-whole-thing"><h4>The Whole Thing</h4><p>Okay, but what about the option <tt class="docutils literal"><span class="pre">-d</span></tt>?</p><pre class="literal-block"><br>args = 'commandname -d cow --debug'.split()<br><br>def getitem(index):<br>    return args[index]<br><br>sys.__getitem__.side_effect = getitem<br><br>with patch('sys.argv', sys):<br>    try:<br>        parsed_args = parser.parse_args()<br>    except Exception as error:<br>        print error<br><br>for item in sys.mock_calls:<br>    print item<br>print parsed_args<br></pre><pre class="literal-block"><br>call.__getitem__(slice(1, None, None))<br>call.__getitem__(slice(1, None, None))<br>call.__getitem__(slice(1, None, None))<br>Namespace(d='cow', debug=True)<br></pre><p>Well, that was kind of painful. On the one hand, I got it to work, on the other hand, I do not really know what the slice is doing since it seems to slice the same items over and over. I think, looking at the first set of calls, after the initial slice it manipulates the sliced copy and since I am passing a real list instead of a mock, the calls are now hidden.</p></div><div class="section" id="looking-at-the-code"><h4>Looking at the Code</h4><p>I downloaded the <a class="reference external" href="http://www.python.org/download/releases/2.7.5/">python 2.7 code</a> and looked in argparse.py and found this:</p><pre class="literal-block"><br>def parse_args(self, args=None, namespace=None):<br>    args, argv = self.parse_known_args(args, namespace)<br></pre><p>There is more to that function, but since it is calling <tt class="docutils literal">parse_known_args</tt> I jumped to it:</p><pre class="literal-block"><br>def parse_known_args(self, args=None, namespace=None):<br>    if args is None:<br>        # args default to the system args<br>        args = _sys.argv[1:]<br></pre><p>Once again there is more code after that, but this explains the slice that is seen in the calls.</p><p>Later on it calls:</p><pre class="literal-block"><br>namespace, args = self._parse_known_args(args, namespace)<br></pre><p>So jumping to <tt class="docutils literal">_parse_known_args</tt>:</p><pre class="literal-block"><br>arg_strings_iter = iter(arg_strings)<br>for i, arg_string in enumerate(arg_strings_iter):<br></pre><p>which I think explains the <cite>__iter__</cite> call in the first set of calls. I tried stepping through the code with <cite>pudb</cite> but could only find one slice, I am not sure what the other calls were for. I suppose it would have been smarter to look at the source code first, but this is about figuring out how to use mock so I think it was helpful to try it empirically first. No fair peeking in the back of the book until you have tried at least once.</p></div></div></body></html>