<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article# " lang="en">
<head>
<meta charset="utf-8">
<base href="https://necromuralist.github.io/index-5.html">
<meta name="description" content="A notebook of things to remember.">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>The Cloistered Monkey (old posts, page 5) | The Cloistered Monkey</title>
<link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<link href="assets/css/ipython.min.css" rel="stylesheet" type="text/css">
<link href="assets/css/nikola_ipython.css" rel="stylesheet" type="text/css">
<meta content="#5670d4" name="theme-color">
<link rel="alternate" type="application/rss+xml" title="RSS" href="rss.xml">
<link rel="canonical" href="https://necromuralist.github.io/index-5.html">
<link rel="prev" href="." type="text/html">
<link rel="next" href="index-4.html" type="text/html">
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
        processEscapes: true
    },
    displayAlign: 'left', // Change this to 'center' to center equations.
    "HTML-CSS": {
        styles: {'.MathJax_Display': {"margin": 0}}
    }
});
</script><!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]--><script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
</script>
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://necromuralist.github.io/">

                <span id="blog-title">The Cloistered Monkey</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="archive.html">Archive</a>
                </li>
<li>
<a href="categories/">Tags</a>
                </li>
<li>
<a href="rss.xml">RSS feed</a>
            </li>
<li class="dropdown">
<a href="#" class="dropdown-toggle" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">Projects <b class="caret"></b></a>
            <ul class="dropdown-menu"><li>
<a href="machine-learning-projects/">Machine Learning</a>
            </li></ul>
</li>
</ul>
<!-- DuckDuckGo custom search --><form method="get" id="search" action="https://duckduckgo.com/" class="navbar-form pull-left">
<input type="hidden" name="sites" value="https://necromuralist.github.io/"><input type="hidden" name="k8" value="#444444"><input type="hidden" name="k9" value="#D51920"><input type="hidden" name="kt" value="h"><input type="text" name="q" maxlength="255" placeholder="Search…" class="span2" style="margin-top: 4px;"><input type="submit" value="DuckDuckGo Search" style="visibility: hidden;">
</form>
<!-- End of custom search -->
#


            <ul class="nav navbar-nav navbar-right"></ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            

<div class="postindex">
    <article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="posts/201310argparse-and-argument-parser/" class="u-url">argparse and the Argument Parser</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn">
                Cloistered Monkey
            </span></p>
            <p class="dateline"><a href="posts/201310argparse-and-argument-parser/" rel="bookmark"><time class="published dt-published" datetime="2013-10-05T22:16:00-07:00" title="2013-10-05 22:16">2013-10-05 22:16</time></a></p>
        </div>
    </header><div class="e-content entry-content">
    <div class="document" id="argparse-and-the-argument-parser">   <p>Mocking the <a class="reference external" href="http://docs.python.org/2/library/argparse.html">argeparse ArgumentParser</a> might not seem like a necessary thing, since you can pass in a list of strings to fake the command-line arguments, but I ran into trouble trying to figure out how to test it embedded in one of my classes so I thought I would explore it anyway, out of curiosity if nothing else. I am primarily interested in mocking the calls to sys.argv to see how it works.</p>
<div class="section" id="sys-argv-calls">
<h4>sys.argv Calls</h4>
<p>Using the <a class="reference external" href="http://www.voidspace.org.uk/python/mock/examples.html#tracking-order-of-calls-and-less-verbose-call-assertions">mock_calls</a> list from <tt class="docutils literal">mock</tt> can be useful in figuring out how an object is being used.</p>
<pre class="literal-block"><br>parser = argparse.ArgumentParser()<br>parser.add_argument('--debug', action='store_true')<br>parser.add_argument('-d')<br><br>sys = MagicMock()<br>with patch('sys.argv', sys):<br>    args = parser.parse_args()<br>for item in sys.mock_calls:<br>    print item<br>print args<br></pre>
<pre class="literal-block"><br>call.__getitem__(slice(1, None, None))<br>call.__getitem__().__iter__()<br>call.__getitem__().__getitem__(slice(0, None, None))<br>call.__getitem__().__getitem__().__iter__()<br>call.__getitem__().__getitem__().__len__()<br>Namespace(d=None, debug=False)<br></pre>
</div>
<div class="section" id="the-getitem-and-slice">
<h4>The getitem and slice</h4>
<p>The first thing to note is the <a class="reference external" href="http://docs.python.org/2/reference/datamodel.html#object.__getitem__">__getitem__</a> calls. According to the documentation it is:</p>
<blockquote>Called to implement evaluation of self[key]. For sequence types, the accepted keys should be integers and slice objects.</blockquote>
<p>So it looks like it is first using the built-in <a class="reference external" href="http://docs.python.org/2/library/functions.html#slice">slice</a> function to get a particular argument. According to the documentation the arguments are the same as for the <tt class="docutils literal">range</tt> function (start, stop, step).</p>
<p>So it looks like it is doing the equivalent of <tt class="docutils literal">[1:]</tt> in the first slice:</p>
<pre class="literal-block"><br>test = [0,1,2]<br><br># what does it do?<br>print test.__getitem__(slice(1, None, None))<br><br># are they the same?<br>print test[1:] == test.__getitem__(slice(1, None, None))<br></pre>
<pre class="literal-block"><br>[1, 2]<br>True<br></pre>
<p>One thing to note is that <tt class="docutils literal">slice(1)</tt> is not the same thing as <tt class="docutils literal">slice(1, None, None)</tt>:</p>
<pre class="literal-block"><br>print slice(1)<br>print slice(1, None, None)<br></pre>
<pre class="literal-block"><br>slice(None, 1, None)<br>slice(1, None, None)<br></pre>
</div>
<div class="section" id="trying-a-lambda">
<h4>Trying a lambda</h4>
<p>So, if I give <tt class="docutils literal">__getitem__</tt> a function to return the arguments I want, will this work?</p>
<pre class="literal-block"><br>sys.__getitem__ = lambda x,y: ['--debug']<br>with patch('sys.argv', sys):<br>    args = parser.parse_args()<br>for item in sys.mock_calls:<br>    print item<br><br>print args<br></pre>
<pre class="literal-block"><br>call.__getitem__(slice(1, None, None))<br>call.__getitem__().__iter__()<br>call.__getitem__().__getitem__(slice(0, None, None))<br>call.__getitem__().__getitem__().__iter__()<br>call.__getitem__().__getitem__().__len__()<br>Namespace(d=None, debug=True)<br></pre>
<p>It looks like it does, but would it be better to just make <tt class="docutils literal">argv</tt> a list?</p>
</div>
<div class="section" id="argv-as-a-list">
<h4>argv as a list</h4>
<pre class="literal-block"><br>args = ['--debug']<br><br>def getitem(index):<br>    return args[index]<br><br># make a new mock since I set __getitem__ to a  lambda function<br>sys = MagicMock()<br>sys.__getitem__.side_effect = getitem<br><br>with patch('sys.argv', sys):<br>    parsed_args = parser.parse_args()<br><br>for item in sys.mock_calls:<br>    print item<br>print parsed_args<br></pre>
<pre class="literal-block"><br>call.__getitem__(slice(1, None, None))<br>Namespace(d=None, debug=False)<br></pre>
<p>It now does not make the other calls and it also does not set the <cite>debug</cite> to True, so it did not work.</p>
<p>But I seem to have forgotten my earlier slice check -- it is starting at the second item. I think that normally the name of the program is the first thing passed in so maybe there needs to be an extra (first) entry to simulate the command name.</p>
</div>
<div class="section" id="adding-a-command-name">
<h4>Adding a Command Name</h4>
<pre class="literal-block"><br>args = 'commandname --debug'.split()<br><br>def getitem(index):<br>    return args[index]<br><br>sys.__getitem__.side_effect = getitem<br><br>with patch('sys.argv', sys):<br>    parsed_args = parser.parse_args()<br><br>for item in sys.mock_calls:<br>    print item<br>print parsed_args<br></pre>
<pre class="literal-block"><br>call.__getitem__(slice(1, None, None))<br>call.__getitem__(slice(1, None, None))<br>Namespace(d=None, debug=True)<br></pre>
<p>It looks like it worked, and all but the first two calls went away, so it perhaps they were a result of me using the mock, not a normal part of the way <cite>parse_args</cite> works.</p>
</div>
<div class="section" id="the-whole-thing">
<h4>The Whole Thing</h4>
<p>Okay, but what about the option <tt class="docutils literal"><span class="pre">-d</span></tt>?</p>
<pre class="literal-block"><br>args = 'commandname -d cow --debug'.split()<br><br>def getitem(index):<br>    return args[index]<br><br>sys.__getitem__.side_effect = getitem<br><br>with patch('sys.argv', sys):<br>    try:<br>        parsed_args = parser.parse_args()<br>    except Exception as error:<br>        print error<br><br>for item in sys.mock_calls:<br>    print item<br>print parsed_args<br></pre>
<pre class="literal-block"><br>call.__getitem__(slice(1, None, None))<br>call.__getitem__(slice(1, None, None))<br>call.__getitem__(slice(1, None, None))<br>Namespace(d='cow', debug=True)<br></pre>
<p>Well, that was kind of painful. On the one hand, I got it to work, on the other hand, I do not really know what the slice is doing since it seems to slice the same items over and over. I think, looking at the first set of calls, after the initial slice it manipulates the sliced copy and since I am passing a real list instead of a mock, the calls are now hidden.</p>
</div>
<div class="section" id="looking-at-the-code">
<h4>Looking at the Code</h4>
<p>I downloaded the <a class="reference external" href="http://www.python.org/download/releases/2.7.5/">python 2.7 code</a> and looked in argparse.py and found this:</p>
<pre class="literal-block"><br>def parse_args(self, args=None, namespace=None):<br>    args, argv = self.parse_known_args(args, namespace)<br></pre>
<p>There is more to that function, but since it is calling <tt class="docutils literal">parse_known_args</tt> I jumped to it:</p>
<pre class="literal-block"><br>def parse_known_args(self, args=None, namespace=None):<br>    if args is None:<br>        # args default to the system args<br>        args = _sys.argv[1:]<br></pre>
<p>Once again there is more code after that, but this explains the slice that is seen in the calls.</p>
<p>Later on it calls:</p>
<pre class="literal-block"><br>namespace, args = self._parse_known_args(args, namespace)<br></pre>
<p>So jumping to <tt class="docutils literal">_parse_known_args</tt>:</p>
<pre class="literal-block"><br>arg_strings_iter = iter(arg_strings)<br>for i, arg_string in enumerate(arg_strings_iter):<br></pre>
<p>which I think explains the <cite>__iter__</cite> call in the first set of calls. I tried stepping through the code with <cite>pudb</cite> but could only find one slice, I am not sure what the other calls were for. I suppose it would have been smarter to look at the source code first, but this is about figuring out how to use mock so I think it was helpful to try it empirically first. No fair peeking in the back of the book until you have tried at least once.</p>
</div>
</div>
    </div>
    </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="posts/201309a-test-of-sphinx-cut-and-paste/" class="u-url">A Test Of Sphinx Cut and Paste</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn">
                Cloistered Monkey
            </span></p>
            <p class="dateline"><a href="posts/201309a-test-of-sphinx-cut-and-paste/" rel="bookmark"><time class="published dt-published" datetime="2013-09-08T19:04:00-07:00" title="2013-09-08 19:04">2013-09-08 19:04</time></a></p>
        </div>
    </header><div class="e-content entry-content">
    <p>This is a test of dumping a cut-and-paste of body text from a sphinx-generated html page.  <br>This is a puzzle from [RTNS].<br></p>
<div class="section" id="the-puzzle">
<h2>The Puzzle<a class="headerlink" href="http://www.blogger.com/blogger.g?blogID=3828623117312978443#the-puzzle" title="Permalink to this headline">¶</a>
</h2>A Spanish treasure fleet of three ships was sunk off the coast of Mexico:<br><blockquote><div><ul class="simple">
<li>One had a trunk of gold forward and a trunk of gold aft</li>
<li>One had a trunk of gold forward and a trunk of silver aft</li>
<li>One had a trunk of silver forward and a trunk of silver aft</li>
</ul></div></blockquote>Divers just found one of the ships and a trunk of silver in it.<br><blockquote><div><ul class="simple"><li>What is the probability that the other trunk has silver?</li></ul></div></blockquote>
</div>
<div class="section" id="a-reasoning">
<h2>A Reasoning<a class="headerlink" href="http://www.blogger.com/blogger.g?blogID=3828623117312978443#a-reasoning" title="Permalink to this headline">¶</a>
</h2>The way to think of this is to not think of each category (silver vs gold) but to identify each trunk and how it is paired with another trunk. For example, we have six trunks:<br><blockquote><div><img alt="G_1, G_2, G_3, S_1, S_2, S_3" class="math" src="posts/_images/math/96b66c02ca526bffc7c662306b084d6f94a1e7ad.png"></div></blockquote>In the three ships they were paired up:<br><blockquote><div><ul class="simple">
<li><img alt="Ship_1 = \{G_1, G_2\}" class="math" src="posts/_images/math/b171671c3dd6dd728e0e1181bba325faa93fa654.png"></li>
<li><img alt="Ship_2 = \{G_3, S_1\}" class="math" src="posts/_images/math/23358509024ea03188202e6b56acdb77c6e53b46.png"></li>
<li><img alt="Ship_3 = \{S_2, S_3\}" class="math" src="posts/_images/math/a35995757f7aeae4cfd5e1908d34dad9b3bf54d6.png"></li>
</ul></div></blockquote>The trunk found had silver so the ship was either <img alt="Ship_2" class="math" src="posts/_images/math/215694a27d4af8de0643a4f32fdca8049454b156.png"> or <img alt="Ship_3" class="math" src="posts/_images/math/3da3ace83a8d796d08a565d76a440d973ef3e8e6.png"> and the trunk was one of <img alt="S_1, S_2, \textrm{or} S_3" class="math" src="posts/_images/math/ca3803bde832b07393dc044bf85c03b4882048af.png">. Call the trunk found <img alt="T_f" class="math" src="posts/_images/math/fa7542bd1fa73e6d35fe0ad5cf035eb914350818.png">.<br><blockquote><div><ul class="simple">
<li>Case 1: <img alt="T_f = S_1" class="math" src="posts/_images/math/82d9e1923f18b498d611616bd87fad5670136c14.png"> then the other trunk will be <img alt="G_3" class="math" src="posts/_images/math/5e592e7c572098aaa72922f31a260997722aab3f.png">
</li>
<li>Case 2: <img alt="T_f = S_2" class="math" src="posts/_images/math/5d4808dd5a47bcd955147b498fd8128bc816d065.png"> then the other trunk will be <img alt="S_3" class="math" src="posts/_images/math/54147dbf4167d407147e92a3439b0d168c96bee8.png">
</li>
<li>Case 3: <img alt="T_f = S_3" class="math" src="posts/_images/math/2390c3ca5bbb0473569703341b3754394360d383.png"> then the other trunk will be <img alt="S_2" class="math" src="posts/_images/math/7f4caea56d945d0b6e49701b42ce06e0fb92e663.png">
</li>
</ul></div></blockquote>In 2 out of 3 cases the trunk will be silver and  in 1 out of 3 cases the trunk will be gold. So the probability that the next trunk pulled up (from the same ship) will be silver will be 2/3.</div>
<div class="section" id="simulation">
<h2>Simulation<a class="headerlink" href="http://www.blogger.com/blogger.g?blogID=3828623117312978443#simulation" title="Permalink to this headline">¶</a>
</h2>This is the method the book gives:<br><blockquote><div><ol class="arabic simple">
<li>Create three urns: {7,7}, {7,8}, and {8,8}</li>
<li>Choose an urn at random and a random element from the chosen urn</li>
<li>If the element chosen was an 8 (gold), do nothing, if it was a 7 continue</li>
<li>Record the other element in the chosen urn</li>
<li>Calculate the proportion of 7s recorded to 8s</li>
</ol></div></blockquote>This seems confusing at first – we know that the trunk found was silver so ship 1 was not the one found, why include it in the simulation? My guess is that we do not need the third urn since we discard all the cases where it is chosen and we are not using the number of trials to find the probabilities. I think the given method might be a clearer simulation if we were trying to recreate what happened in that it reflects the entire story, but it does not really reflect the puzzle at the point it takes up – after the first trunk is found –  so adds unnecessary computation (well, I guess the whole random choice thing is probably doing that anyway).<br>Try this:<br><blockquote><div><ol class="arabic simple">
<li>Create two urns: {0,1}, {1,1}</li>
<li>Pick a random urn and an element from it</li>
<li>If the element was a 0, go back a step</li>
<li>Record the remaining element in the urn</li>
<li>calculate the ratio of 1’s to 0’s</li>
</ol></div></blockquote>This is confusing, he says find the odds, but 2/3 is probability. The odds of finding silver should be 2:1 (he also flip-flops between saying they found silver and gold in the first trunk, but that is another problem – and the book was free, so what the heck).<br><br><div class="highlight-python"><div class="highlight">
<pre><span class="n">GOLD</span> <span class="o">=</span> <span class="mi">0</span><br><span class="n">SILVER</span> <span class="o">=</span> <span class="mi">1</span><br><span class="n">ship_2</span> <span class="o">=</span> <span class="p">(</span><span class="n">GOLD</span><span class="p">,</span> <span class="n">SILVER</span><span class="p">)</span><br><span class="n">ship_3</span> <span class="o">=</span> <span class="p">(</span><span class="n">SILVER</span><span class="p">,</span> <span class="n">SILVER</span><span class="p">)</span><br><span class="n">fleet</span> <span class="o">=</span> <span class="p">(</span><span class="n">ship_2</span><span class="p">,</span> <span class="n">ship_3</span><span class="p">)</span><br><span class="n">trials</span> <span class="o">=</span> <span class="mi">10</span><span class="o">**</span><span class="mi">5</span><br><br><span class="c"># ships is a list of random ships from the fleet</span><br><span class="n">ships</span> <span class="o">=</span> <span class="p">[</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">fleet</span><span class="p">)</span> <span class="k">for</span> <span class="n">trial</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">trials</span><span class="p">)]</span><br><br><span class="c"># found_trunks is a list of trunk-indices chosen for each ship (the trunk found by the diver)</span><br><span class="c"># although the values are the same as gold and silver (0 and 1)</span><br><span class="c"># in this case they are tuple indices for the trunk-tuples in the ships</span><br><span class="n">found_trunks</span> <span class="o">=</span> <span class="p">[</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">ship</span> <span class="ow">in</span> <span class="n">ships</span><span class="p">]</span><br><br><span class="c"># next_trunks is the type of trunk not chosen for found_trunks if found_trunks wasn't gold</span><br><span class="c"># because it's filtered, its length is the count of all cases where the first trunk was silver</span><br><span class="n">next_trunks</span> <span class="o">=</span> <span class="p">[</span><span class="n">ships</span><span class="p">[</span><span class="n">index</span><span class="p">][(</span><span class="n">found_trunks</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ships</span><span class="p">))</span><br><span class="k">if</span> <span class="n">ships</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="n">found_trunks</span><span class="p">[</span><span class="n">index</span><span class="p">]]</span> <span class="o">!=</span> <span class="n">GOLD</span><span class="p">]</span><br><br><span class="c"># silvers is a count of the next_trunks that were silver</span><br><span class="n">silvers</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">trunk</span> <span class="ow">in</span> <span class="n">next_trunks</span> <span class="k">if</span> <span class="n">trunk</span> <span class="o">==</span> <span class="n">SILVER</span><span class="p">)</span><br><br><span class="k">print</span> <span class="s">"Probability next trunk is silver: {0:.2f}"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">silvers</span><span class="p">)</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">next_trunks</span><span class="p">))</span><br><span class="k">print</span> <span class="s">"(Compare to 2/3 = {0:.2f})."</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="mf">2.</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span> </pre>
<pre> </pre>
</div></div>Probability next trunk is silver: 0.67 (Compare to 2/3 = 0.67).</div>
    </div>
    </article>
</div>

        <nav class="postindexpager"><ul class="pager">
<li class="previous">
                <a href="." rel="prev">Newer posts</a>
            </li>
            <li class="next">
                <a href="index-4.html" rel="next">Older posts</a>
            </li>
        </ul></nav>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2016         <a href="mailto:necromuralist@gmail.com">Cloistered Monkey</a> - Powered by         <a href="https://getnikola.com" rel="nofollow">Nikola</a>         
            
        </footer>
</div>
</div>


            <script src="assets/js/all-nocdn.js"></script><script>$('a.image-reference:not(.islink) img:not(.islink)').parent().colorbox({rel:"gal",maxWidth:"100%",maxHeight:"100%",scalePhotos:true});</script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(1, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates -->
</body>
</html>
