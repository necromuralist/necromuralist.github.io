<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>The Cloistered Monkey (Posts about networking)</title><link>https://necromuralist.github.io/</link><description></description><atom:link href="https://necromuralist.github.io/categories/networking.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents © 2020 &lt;a href="mailto:necromuralist@protonmail.com"&gt;Cloistered Monkey&lt;/a&gt; </copyright><lastBuildDate>Thu, 10 Sep 2020 23:06:34 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>The Linux IPv6 Router Advertisement Daemon (radvd)</title><link>https://necromuralist.github.io/posts/the-linux-ipv6-router-advertisement-daemon-radvd/</link><dc:creator>Cloistered Monkey</dc:creator><description>&lt;div id="outline-container-org81d0acd" class="outline-2"&gt;
&lt;h2 id="org81d0acd"&gt;Background&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org81d0acd"&gt;
&lt;p&gt;
&lt;a href="http://www.litech.org/radvd/"&gt;radvd&lt;/a&gt; (the router advertisement daemon) sends IPv6 advertisements and responds to node IPv6 requests. Here's the description from the man page.
&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;
&lt;b&gt;radvd&lt;/b&gt; is the router advertisement daemon for IPv6. It listens to router solicitations and sends router advertisements as described in "Neighbor Discovery for IP Version 6 (IPv6)" (RFC 4861). With these advertisements hosts can automatically configure their addresses and some other parameters. They also can choose a default router based on these advertisements. 
&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org7a23eba" class="outline-2"&gt;
&lt;h2 id="org7a23eba"&gt;Installation and Setup&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org7a23eba"&gt;
&lt;p&gt;
Setting &lt;b&gt;radvd&lt;/b&gt; is suspiciously easy compared to other linux services. First you install it.
&lt;/p&gt;

&lt;pre class="example"&gt;
sudo apt install radvd
&lt;/pre&gt;

&lt;p&gt;
Installing it will also start the service so we can use &lt;code&gt;systemctl&lt;/code&gt; to check how it's doing.
&lt;/p&gt;

&lt;pre class="example"&gt;
systemctl status radvd
&lt;/pre&gt;

&lt;pre class="example"&gt;
systemctl status radvd
● radvd.service - LSB: Router Advertising Daemon
   Loaded: loaded (/etc/init.d/radvd; bad; vendor preset: enabled)
   Active: active (exited) since Fri 2018-07-20 12:39:19 PDT; 36s ago
     Docs: man:systemd-sysv-generator(8)

Jul 20 12:39:18 asgaard systemd[1]: Starting LSB: Router Advertising Daemon...
Jul 20 12:39:19 asgaard radvd[8532]: Starting radvd:
Jul 20 12:39:19 asgaard radvd[8532]: * /etc/radvd.conf does not exist or is empty.
Jul 20 12:39:19 asgaard radvd[8532]: * See /usr/share/doc/radvd/README.Debian
Jul 20 12:39:19 asgaard radvd[8532]: * radvd will *not* be started.
Jul 20 12:39:19 asgaard systemd[1]: Started LSB: Router Advertising Daemon.
&lt;/pre&gt;

&lt;p&gt;
You can see in the output that there's a line with &lt;code&gt;/etc/radvd.conf does not exist or is empty.&lt;/code&gt;. To fix this we're going to create the configuration file.
&lt;/p&gt;
&lt;/div&gt;

&lt;div id="outline-container-org3e25360" class="outline-3"&gt;
&lt;h3 id="org3e25360"&gt;The Configuration File&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org3e25360"&gt;
&lt;p&gt;
Now create a configuration file (named &lt;code&gt;radvd.conf&lt;/code&gt;). Here's an example.
&lt;/p&gt;

&lt;pre class="example"&gt;
interface eth0
{
MinRtrAdvInterval 3;
MaxRtrAdvInterval 4;
AdvSendAdvert on;
AdvManagedFlag on;
prefix 2001:db7::/64
{ AdvValidLifetime 14300; AdvPreferredLifetime 14200; }
;
};
&lt;/pre&gt;

&lt;p&gt;
Note that the interface name depends on your system. Most linux systems don't use the &lt;code&gt;eth0&lt;/code&gt; convention anymore. On my desktop the ethernet inteface is called &lt;code&gt;enp1s0&lt;/code&gt; and on my raspberry pi it's &lt;code&gt;enxb827eb6c9129&lt;/code&gt; so make sure you check what your interface name is using &lt;code&gt;ifconfig&lt;/code&gt;.
&lt;/p&gt;

&lt;p&gt;
Now move (or copy) the config file into &lt;code&gt;/etc/&lt;/code&gt;
&lt;/p&gt;

&lt;pre class="example"&gt;
sudo mv radvd.conf /etc/
&lt;/pre&gt;

&lt;p&gt;
And then restart &lt;code&gt;radvd&lt;/code&gt; and check its state.
&lt;/p&gt;

&lt;pre class="example"&gt;
sudo service radvd restart
systemctl status radvd
&lt;/pre&gt;

&lt;pre class="example"&gt;
● radvd.service - LSB: Router Advertising Daemon
   Loaded: loaded (/etc/init.d/radvd; bad; vendor preset: enabled)
   Active: active (exited) since Fri 2018-07-20 12:41:36 PDT; 2s ago
     Docs: man:systemd-sysv-generator(8)
  Process: 10008 ExecStop=/etc/init.d/radvd stop (code=exited, status=0/SUCCESS)
  Process: 10017 ExecStart=/etc/init.d/radvd start (code=exited, status=0/SUCCESS)

Jul 20 12:41:36 asgaard systemd[1]: Starting LSB: Router Advertising Daemon...
Jul 20 12:41:36 asgaard radvd[10017]: Starting radvd:
Jul 20 12:41:36 asgaard radvd[10017]: * IPv6 forwarding seems to be disabled.
Jul 20 12:41:36 asgaard radvd[10017]: * See /usr/share/doc/radvd/README.Debian
Jul 20 12:41:36 asgaard radvd[10017]: * radvd will *not* be started.
Jul 20 12:41:36 asgaard systemd[1]: Started LSB: Router Advertising Daemon.
&lt;/pre&gt;

&lt;p&gt;
So the warning about the configuration file went away, now we have to fix the &lt;code&gt;IPv6 forwarding seems to be disabled.&lt;/code&gt; error.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org9a2660b" class="outline-3"&gt;
&lt;h3 id="org9a2660b"&gt;Enable IPv6 Forwarding&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org9a2660b"&gt;
&lt;p&gt;
For now you can enable it at the command line.
&lt;/p&gt;

&lt;pre class="example"&gt;
sudo sysctl -w net.ipv6.conf.all.forwarding=1
&lt;/pre&gt;

&lt;p&gt;
And restart and check &lt;code&gt;radvd&lt;/code&gt; again.
&lt;/p&gt;

&lt;pre class="example"&gt;
sudo service radvd restart
systemctl status radvd
&lt;/pre&gt;

&lt;pre class="example"&gt;
● radvd.service - LSB: Router Advertising Daemon
   Loaded: loaded (/etc/init.d/radvd; bad; vendor preset: enabled)
   Active: active (running) since Fri 2018-07-20 12:45:02 PDT; 20s ago
     Docs: man:systemd-sysv-generator(8)
  Process: 12255 ExecStop=/etc/init.d/radvd stop (code=exited, status=0/SUCCESS)
  Process: 12264 ExecStart=/etc/init.d/radvd start (code=exited, status=0/SUCCESS)
   CGroup: /system.slice/radvd.service
           ├─12275 /usr/sbin/radvd -u radvd -p /var/run/radvd/radvd.pid
           └─12276 /usr/sbin/radvd -u radvd -p /var/run/radvd/radvd.pid

Jul 20 12:45:01 asgaard systemd[1]: Starting LSB: Router Advertising Daemon...
Jul 20 12:45:02 asgaard radvd[12274]: version 2.11 started
Jul 20 12:45:02 asgaard radvd[12264]: Starting radvd: radvd.
Jul 20 12:45:02 asgaard systemd[1]: Started LSB: Router Advertising Daemon.
&lt;/pre&gt;

&lt;p&gt;
So it looks like our daemon is working. If you restart the server, though, the IPv6 port forwarding won't be enabled so open up &lt;code&gt;/etc/sysctl.conf&lt;/code&gt; and un-comment out the following line.
&lt;/p&gt;

&lt;pre class="example"&gt;
net.ipv6.conf.all.forwarding=1
&lt;/pre&gt;

&lt;p&gt;
Now the next time you power on the computer it should be enabled.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org65f1bc7" class="outline-2"&gt;
&lt;h2 id="org65f1bc7"&gt;Checking&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org65f1bc7"&gt;
&lt;p&gt;
To check if it's working you can put another device on the LAN and check &lt;code&gt;ifconfig&lt;/code&gt;. In our &lt;code&gt;radvd.conf&lt;/code&gt; file we defined the prefix for the address:
&lt;/p&gt;

&lt;pre class="example"&gt;
prefix 2001:db7::/64
&lt;/pre&gt;

&lt;p&gt;
So in the &lt;code&gt;ifconfig&lt;/code&gt; output  we should see an entry for an IPv6 address that starts with &lt;code&gt;2001:db7::&lt;/code&gt;. In fact I ended up with two.
&lt;/p&gt;

&lt;pre class="example"&gt;
inet6 2001:db7::b8b4:6adf:6267:5571  prefixlen 64  scopeid 0x0&amp;lt;global&amp;gt;
inet6 2001:db7::a80c:1a05:eaac:c1e8  prefixlen 64  scopeid 0x0&amp;lt;global&amp;gt;
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org90b2db0" class="outline-2"&gt;
&lt;h2 id="org90b2db0"&gt;Sources&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org90b2db0"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;a href="https://www.linux.com/learn/intro-to-linux/2017/12/ipv6-auto-configuration-linux"&gt;IPv6 auto-configuration&lt;/a&gt; - how to setup &lt;b&gt;radvd&lt;/b&gt; (from linux.com)&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>how-to</category><category>networking</category><guid>https://necromuralist.github.io/posts/the-linux-ipv6-router-advertisement-daemon-radvd/</guid><pubDate>Fri, 20 Jul 2018 18:12:11 GMT</pubDate></item><item><title>Networking Tools</title><link>https://necromuralist.github.io/posts/networking-tools/</link><dc:creator>Cloistered Monkey</dc:creator><description>&lt;div id="outline-container-orgab17277" class="outline-2"&gt;
&lt;h2 id="orgab17277"&gt;Packet Capturing&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgab17277"&gt;
&lt;/div&gt;
&lt;div id="outline-container-org5593837" class="outline-3"&gt;
&lt;h3 id="org5593837"&gt;&lt;a href="http://staff.washington.edu/corey/gulp/"&gt;Gulp&lt;/a&gt;&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org5593837"&gt;
&lt;p&gt;
Gulp purports to be better at capturing packets than tcpdump (although they can work together).
&lt;/p&gt;

&lt;p&gt;
There is more than one version out there:
&lt;/p&gt;

&lt;p&gt;
-&lt;a href="//github.com/gsson/gulp"&gt; This one&lt;/a&gt; says it applied a patch to it five years ago. 
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;a href="https://github.com/aokunev/gulp-v01"&gt;This one&lt;/a&gt; says it is the original but hasn't been updated in six years.&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.crox.net/archives/72-gulp-tcpdump-alternative-for-lossless-capture-on-Linux.html"&gt;This blog post&lt;/a&gt; has updated versions of it including one in 2017 that says it has a major bug fix (but I don't know if it's a gulp bug or not)&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org1169b35" class="outline-3"&gt;
&lt;h3 id="org1169b35"&gt;&lt;a href="https://www.tcpdump.org"&gt;tcpdump&lt;/a&gt;&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org1169b35"&gt;
&lt;p&gt;
More easily obtainable and better documentation available (although still not enough).
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org20c8875" class="outline-3"&gt;
&lt;h3 id="org20c8875"&gt;&lt;a href="http://ssldump.sourceforge.net"&gt;ssldump&lt;/a&gt;&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org20c8875"&gt;
&lt;p&gt;
Captures packets and decodes SSL/TLS packets.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org5b647d4" class="outline-2"&gt;
&lt;h2 id="org5b647d4"&gt;Packet Examining&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org5b647d4"&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgfda0c5d" class="outline-3"&gt;
&lt;h3 id="orgfda0c5d"&gt;&lt;a href="https://github.com/mschiffm/cppip"&gt;Compressed PCAP Packet Indexing Prograpm (cppip)&lt;/a&gt;&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgfda0c5d"&gt;
&lt;p&gt;
This adds indexing to &lt;a href="http://www.htslib.org/doc/bgzip.html"&gt;bgzip&lt;/a&gt; compressed LibPCAP files which then lets you extract them while the original files are still compressed.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org8c6a46f" class="outline-3"&gt;
&lt;h3 id="org8c6a46f"&gt;&lt;a href="https://linux.die.net/man/8/tcpslice"&gt;tcpslice&lt;/a&gt;&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org8c6a46f"&gt;
&lt;p&gt;
This lets you extract part of or combine files created by tcpdump when using file rotation.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgec2b3c9" class="outline-3"&gt;
&lt;h3 id="orgec2b3c9"&gt;&lt;a href="https://github.com/jpr5/ngrep"&gt;ngrep&lt;/a&gt;&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgec2b3c9"&gt;
&lt;p&gt;
Describes itself as like GNU grep but for packets.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org8a628e1" class="outline-3"&gt;
&lt;h3 id="org8a628e1"&gt;&lt;a href="https://github.com/signed0/pylibpcap"&gt;pylibpcap&lt;/a&gt;, &lt;a href="https://github.com/pynetwork/pypcap"&gt;pypcap&lt;/a&gt;&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org8a628e1"&gt;
&lt;p&gt;
Python code to work with libpcap.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgf42e18c" class="outline-3"&gt;
&lt;h3 id="orgf42e18c"&gt;WireShark&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgf42e18c"&gt;
&lt;p&gt;
These are installed when you install wireshark.
&lt;/p&gt;
&lt;/div&gt;
&lt;div id="outline-container-org8edf477" class="outline-4"&gt;
&lt;h4 id="org8edf477"&gt;&lt;a href="https://www.wireshark.org/docs/man-pages/tshark.html"&gt;tshark&lt;/a&gt;/&lt;a href="https://www.wireshark.org"&gt;wireshark&lt;/a&gt;&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org8edf477"&gt;
&lt;p&gt;
Packet capturing and examining (better documented than most of the other programs)
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org2757fa0" class="outline-4"&gt;
&lt;h4 id="org2757fa0"&gt;&lt;a href="https://www.wireshark.org/docs/man-pages/reordercap.html"&gt;reordercap&lt;/a&gt;&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org2757fa0"&gt;
&lt;p&gt;
Reorders the packets by timestamp.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgc532c9c" class="outline-4"&gt;
&lt;h4 id="orgc532c9c"&gt;&lt;a href="https://www.wireshark.org/docs/man-pages/capinfos.html"&gt;capinfos&lt;/a&gt;&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-orgc532c9c"&gt;
&lt;p&gt;
This prints summary information about packe files (works with gzipped files).
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org5e6a26f" class="outline-4"&gt;
&lt;h4 id="org5e6a26f"&gt;&lt;a href="https://www.wireshark.org/docs/man-pages/mergecap.html"&gt;mergecap&lt;/a&gt;&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org5e6a26f"&gt;
&lt;p&gt;
Merges multiple packet files together. Mergecap will try to keep timestamps in order when merging, but it assumes each individual file to merge is already in order.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org43997dd" class="outline-2"&gt;
&lt;h2 id="org43997dd"&gt;Packet Flows&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org43997dd"&gt;
&lt;/div&gt;
&lt;div id="outline-container-org787326a" class="outline-3"&gt;
&lt;h3 id="org787326a"&gt;&lt;a href="http://tcpick.sourceforge.net"&gt;tcpick&lt;/a&gt;&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org787326a"&gt;
&lt;p&gt;
Track, reassemble, reorder TCP streams.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgf8353ae" class="outline-3"&gt;
&lt;h3 id="orgf8353ae"&gt;&lt;a href="http://www.tcptrace.org"&gt;tcptrace&lt;/a&gt;&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgf8353ae"&gt;
&lt;p&gt;
Gives connection information taken from a capture file.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org288000e" class="outline-3"&gt;
&lt;h3 id="org288000e"&gt;&lt;a href="https://github.com/simsong/tcpflow"&gt;tcpflow&lt;/a&gt;&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org288000e"&gt;
&lt;p&gt;
Separates out TCP flows into separate files.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org6c58bde" class="outline-2"&gt;
&lt;h2 id="org6c58bde"&gt;Capture Summarizing&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org6c58bde"&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgb7eebe9" class="outline-3"&gt;
&lt;h3 id="orgb7eebe9"&gt;&lt;a href="https://www.wireshark.org/docs/man-pages/capinfos.html"&gt;capinfos&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div id="outline-container-org7da3ba6" class="outline-3"&gt;
&lt;h3 id="org7da3ba6"&gt;&lt;a href="https://github.com/kohler/ipsumdump"&gt;ipsumdump&lt;/a&gt;&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org7da3ba6"&gt;
&lt;p&gt;
Summarizes packet information in ASCII format
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orge8d017f" class="outline-3"&gt;
&lt;h3 id="orge8d017f"&gt;&lt;a href="http://www.draconyx.net/articles/tcpdstat-fixing-a-compilation-bug-and-using-statistics.html"&gt;tcpdstat&lt;/a&gt;&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orge8d017f"&gt;
&lt;p&gt;
Gives summary statistics for a pcap file
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org6b12f54" class="outline-2"&gt;
&lt;h2 id="org6b12f54"&gt;Network Monitoring&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org6b12f54"&gt;
&lt;/div&gt;
&lt;div id="outline-container-org516dd38" class="outline-3"&gt;
&lt;h3 id="org516dd38"&gt;&lt;a href="https://www.ntop.org"&gt;ntop&lt;/a&gt;&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org516dd38"&gt;
&lt;p&gt;
Like top but for the network.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orga21e5ee" class="outline-3"&gt;
&lt;h3 id="orga21e5ee"&gt;&lt;a href="http://man7.org/linux/man-pages/man8/ss.8.html"&gt;ss (socket statistics)&lt;/a&gt;&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orga21e5ee"&gt;
&lt;p&gt;
Part of &lt;a href="https://en.wikipedia.org/wiki/Iproute2"&gt;iproute2&lt;/a&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org2a1bec7" class="outline-2"&gt;
&lt;h2 id="org2a1bec7"&gt;Miscellaneous&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org2a1bec7"&gt;
&lt;/div&gt;
&lt;div id="outline-container-org111d2e5" class="outline-3"&gt;
&lt;h3 id="org111d2e5"&gt;&lt;a href="http://tcpreplay.appneta.com/"&gt;tcpreplay&lt;/a&gt;&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org111d2e5"&gt;
&lt;p&gt;
A suite of programs to edit and replay pcap files.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgfcc75a6" class="outline-3"&gt;
&lt;h3 id="orgfcc75a6"&gt;&lt;a href="https://en.wikipedia.org/wiki/Netcat"&gt;netcat&lt;/a&gt;&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgfcc75a6"&gt;
&lt;p&gt;
Read from and write to TCP/UDP network connections.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org262f90e" class="outline-3"&gt;
&lt;h3 id="org262f90e"&gt;&lt;a href="https://linux.die.net/man/1/socat"&gt;socat&lt;/a&gt;&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org262f90e"&gt;
&lt;p&gt;
Route data between byte streams.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>networking</category><category>tools</category><category>wireless</category><guid>https://necromuralist.github.io/posts/networking-tools/</guid><pubDate>Tue, 22 May 2018 20:57:42 GMT</pubDate></item><item><title>TCP Dump Notes</title><link>https://necromuralist.github.io/posts/tcp-dump-notes/</link><dc:creator>Cloistered Monkey</dc:creator><description>&lt;p&gt;
These are notes I made while surfing the web looking into &lt;a href="http://www.tcpdump.org/"&gt;TCP Dump&lt;/a&gt;. You will most likely need to use &lt;code&gt;sudo&lt;/code&gt; to run most of the commands, but I'm leaving it off to make it shorter.
&lt;/p&gt;

&lt;div id="outline-container-orgb2d9292" class="outline-2"&gt;
&lt;h2 id="orgb2d9292"&gt;About TCP Dump&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgb2d9292"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;It has more filtering capabilities and can filter while capturing packets, but it doesn't have the analytical tools that something like wireshark has&lt;sup&gt;&lt;a id="fnr.1" class="footref" href="https://necromuralist.github.io/posts/tcp-dump-notes/#fn.1"&gt;1&lt;/a&gt;&lt;/sup&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org1549858" class="outline-2"&gt;
&lt;h2 id="org1549858"&gt;Some Examples&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org1549858"&gt;
&lt;/div&gt;
&lt;div id="outline-container-org9a4aede" class="outline-3"&gt;
&lt;h3 id="org9a4aede"&gt;Listing interfaces&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org9a4aede"&gt;
&lt;p&gt;
You can ask &lt;code&gt;tcpdump&lt;/code&gt; which interfaces it is able to listen to&lt;sup&gt;&lt;a id="fnr.2" class="footref" href="https://necromuralist.github.io/posts/tcp-dump-notes/#fn.2"&gt;2&lt;/a&gt;&lt;/sup&gt;.
&lt;/p&gt;

&lt;pre class="example"&gt;
tcpdump -D
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orge2046fa" class="outline-3"&gt;
&lt;h3 id="orge2046fa"&gt;Capture packets on an interface&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orge2046fa"&gt;
&lt;p&gt;
To capture packets on an interface you pass its name to the &lt;code&gt;-i&lt;/code&gt; flag&lt;sup&gt;&lt;a id="fnr.2.100" class="footref" href="https://necromuralist.github.io/posts/tcp-dump-notes/#fn.2"&gt;2&lt;/a&gt;&lt;/sup&gt; (here the interface I'll use is &lt;code&gt;eno1&lt;/code&gt;).
&lt;/p&gt;

&lt;pre class="example"&gt;
tcpdump -i eno1
&lt;/pre&gt;
&lt;/div&gt;

&lt;div id="outline-container-org334db25" class="outline-4"&gt;
&lt;h4 id="org334db25"&gt;Save the packet capture to a file&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org334db25"&gt;
&lt;p&gt;
The default behavior is for &lt;code&gt;tcpdump&lt;/code&gt; to send the output to standard output, to have it save the packets to a files use the &lt;code&gt;-w&lt;/code&gt; flag&lt;sup&gt;&lt;a id="fnr.2.100" class="footref" href="https://necromuralist.github.io/posts/tcp-dump-notes/#fn.2"&gt;2&lt;/a&gt;&lt;/sup&gt; (you can call it anything, I'll call it &lt;code&gt;dump.pcap&lt;/code&gt;).
&lt;/p&gt;

&lt;pre class="example"&gt;
tcpdump -i eno1 -w dump.pcap
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org107889f" class="outline-4"&gt;
&lt;h4 id="org107889f"&gt;Increase the verbosity of the capture&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org107889f"&gt;
&lt;p&gt;
To increase the amount if information that's captured, pass multiple &lt;code&gt;v&lt;/code&gt; arguments&lt;sup&gt;&lt;a id="fnr.2.100" class="footref" href="https://necromuralist.github.io/posts/tcp-dump-notes/#fn.2"&gt;2&lt;/a&gt;&lt;/sup&gt; (in this case I'll use &lt;code&gt;-vvv&lt;/code&gt;).
&lt;/p&gt;

&lt;pre class="example"&gt;
tcpdump -i eno1 -vvv -w dump.pcap
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgd52af55" class="outline-3"&gt;
&lt;h3 id="orgd52af55"&gt;Filtering&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgd52af55"&gt;
&lt;/div&gt;
&lt;div id="outline-container-orge792409" class="outline-4"&gt;
&lt;h4 id="orge792409"&gt;By IP address&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-orge792409"&gt;
&lt;p&gt;
You can get all the packets being sent or received by a host using the &lt;code&gt;host&lt;/code&gt; argument&lt;sup&gt;&lt;a id="fnr.3" class="footref" href="https://necromuralist.github.io/posts/tcp-dump-notes/#fn.3"&gt;3&lt;/a&gt;&lt;/sup&gt;.
&lt;/p&gt;

&lt;pre class="example"&gt;
tcpdump host 192.168.1.12
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orge5e917e" class="outline-4"&gt;
&lt;h4 id="orge5e917e"&gt;By Sender IP Address&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-orge5e917e"&gt;
&lt;p&gt;
You can filter out all the packets except those that are being sent by a host using the &lt;code&gt;src host&lt;/code&gt; argument&lt;sup&gt;&lt;a id="fnr.2.100" class="footref" href="https://necromuralist.github.io/posts/tcp-dump-notes/#fn.2"&gt;2&lt;/a&gt;&lt;/sup&gt;.
&lt;/p&gt;

&lt;pre class="example"&gt;
tcpdump -i eno1 src host 192.168.1.12
&lt;/pre&gt;

&lt;p&gt;
You can leave off the &lt;code&gt;host&lt;/code&gt; argument and just use &lt;code&gt;src&lt;/code&gt;&lt;sup&gt;&lt;a id="fnr.3.100" class="footref" href="https://necromuralist.github.io/posts/tcp-dump-notes/#fn.3"&gt;3&lt;/a&gt;&lt;/sup&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orge8c0a37" class="outline-4"&gt;
&lt;h4 id="orge8c0a37"&gt;By Target IP Address&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-orge8c0a37"&gt;
&lt;p&gt;
To filter out all the packets except those that are going to a specific target use the &lt;code&gt;dst host&lt;/code&gt; argument&lt;sup&gt;&lt;a id="fnr.2.100" class="footref" href="https://necromuralist.github.io/posts/tcp-dump-notes/#fn.2"&gt;2&lt;/a&gt;&lt;/sup&gt;.
&lt;/p&gt;

&lt;pre class="example"&gt;
tcpdump -i eno1 dst host 192.168.1.1
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org00f3884" class="outline-4"&gt;
&lt;h4 id="org00f3884"&gt;Sender and Target IP Addresses&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org00f3884"&gt;
&lt;p&gt;
You can combine parameters using the logical operators &lt;code&gt;and&lt;/code&gt;, &lt;code&gt;or&lt;/code&gt;, and &lt;code&gt;not&lt;/code&gt;&lt;sup&gt;&lt;a id="fnr.3.100" class="footref" href="https://necromuralist.github.io/posts/tcp-dump-notes/#fn.3"&gt;3&lt;/a&gt;&lt;/sup&gt;.
&lt;/p&gt;

&lt;pre class="example"&gt;
tcpdump 'src 192.168.1.1 and dst 192.168.1.12'
&lt;/pre&gt;

&lt;p&gt;
The single quotes are optional and are just used to group the arguments together.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org0a3f775" class="outline-4"&gt;
&lt;h4 id="org0a3f775"&gt;By Subnet&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org0a3f775"&gt;
&lt;p&gt;
You can grab all the packets on a network or subnet using the &lt;code&gt;net&lt;/code&gt; argument and &lt;a href="https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing#CIDR_notation"&gt;CIDR&lt;/a&gt; notation&lt;sup&gt;&lt;a id="fnr.3.100" class="footref" href="https://necromuralist.github.io/posts/tcp-dump-notes/#fn.3"&gt;3&lt;/a&gt;&lt;/sup&gt;. This example grabs all the packets on the &lt;code&gt;192.168.1.*&lt;/code&gt; subnet.
&lt;/p&gt;

&lt;pre class="example"&gt;
tcpdump net 192.168.1.0/24
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org738268e" class="outline-4"&gt;
&lt;h4 id="org738268e"&gt;By port and/or protocol&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org738268e"&gt;
&lt;p&gt;
If you want to only catch activity on a certain &lt;a href="https://en.wikipedia.org/wiki/Port_(computer_networking)"&gt;port&lt;/a&gt; and by a certain protocol then you use the &lt;code&gt;port&lt;/code&gt; argument and the name of the protocol (e.g. &lt;code&gt;udp&lt;/code&gt;)&lt;sup&gt;&lt;a id="fnr.3.100" class="footref" href="https://necromuralist.github.io/posts/tcp-dump-notes/#fn.3"&gt;3&lt;/a&gt;&lt;/sup&gt;. This would catch all the &lt;code&gt;tcp&lt;/code&gt; traffic over SSH.
&lt;/p&gt;
&lt;pre class="example"&gt;
tcpdump tcp port 22
&lt;/pre&gt;

&lt;p&gt;
You can use &lt;code&gt;tcp&lt;/code&gt;, &lt;code&gt;udp&lt;/code&gt;, or &lt;code&gt;icmp&lt;/code&gt; for the protocols and add multiple ports using a comma&lt;sup&gt;&lt;a id="fnr.4" class="footref" href="https://necromuralist.github.io/posts/tcp-dump-notes/#fn.4"&gt;4&lt;/a&gt;&lt;/sup&gt;.
&lt;/p&gt;

&lt;pre class="example"&gt;
tcpdump tcp port 22,80
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org5478b89" class="outline-4"&gt;
&lt;h4 id="org5478b89"&gt;Turn off hostname and port translation&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org5478b89"&gt;
&lt;p&gt;
The default behavior for &lt;code&gt;tcpdump&lt;/code&gt; is to translate the hostnames and ports to something human-readable if possible. To turn this off you pass in the &lt;code&gt;-n&lt;/code&gt; argument&lt;sup&gt;&lt;a id="fnr.3.100" class="footref" href="https://necromuralist.github.io/posts/tcp-dump-notes/#fn.3"&gt;3&lt;/a&gt;&lt;/sup&gt;. Since this stops having to look things up it will reduce the amount of overhead needed by &lt;code&gt;tcpdump&lt;/code&gt;.
&lt;/p&gt;

&lt;pre class="example"&gt;
tcpdump -n -i eno1 port 22
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgf02cbde" class="outline-2"&gt;
&lt;h2 id="orgf02cbde"&gt;Links&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgf02cbde"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;(Wireshark Revealed&lt;sup&gt;&lt;a id="fnr.5" class="footref" href="https://necromuralist.github.io/posts/tcp-dump-notes/#fn.5"&gt;5&lt;/a&gt;&lt;/sup&gt;) &lt;a href="http://www.tcpdump.org/"&gt;The tcpdump website&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;(Wireshark Revealed&lt;sup&gt;&lt;a id="fnr.5.100" class="footref" href="https://necromuralist.github.io/posts/tcp-dump-notes/#fn.5"&gt;5&lt;/a&gt;&lt;/sup&gt;) &lt;a href="http://danielmiessler.com/study/tcpdump/"&gt;A friendly tutorial&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;(Wireshark Revealed&lt;sup&gt;&lt;a id="fnr.5.100" class="footref" href="https://necromuralist.github.io/posts/tcp-dump-notes/#fn.5"&gt;5&lt;/a&gt;&lt;/sup&gt;) &lt;a href="http://www.tcpdump.org/tcpdump_man.html"&gt;The official man page&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org50e59f0" class="outline-2"&gt;
&lt;h2 id="org50e59f0"&gt;Sources&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org50e59f0"&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="footnotes"&gt;
&lt;h2 class="footnotes"&gt;Footnotes: &lt;/h2&gt;
&lt;div id="text-footnotes"&gt;

&lt;div class="footdef"&gt;&lt;sup&gt;&lt;a id="fn.1" class="footnum" href="https://necromuralist.github.io/posts/tcp-dump-notes/#fnr.1"&gt;1&lt;/a&gt;&lt;/sup&gt; &lt;div class="footpara"&gt;&lt;p class="footpara"&gt;
Diogenes, Y. &amp;amp; Ozkaya, E. (2018). Cybersecurity, Attack and Defense Strategies : infrastructure security with Red Team and Blue Team tactics. Birmingham, UK: Packt Publishing.]
&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class="footdef"&gt;&lt;sup&gt;&lt;a id="fn.2" class="footnum" href="https://necromuralist.github.io/posts/tcp-dump-notes/#fnr.2"&gt;2&lt;/a&gt;&lt;/sup&gt; &lt;div class="footpara"&gt;&lt;p class="footpara"&gt;
Johansen, G. (2017). Digital forensics and incident response : an intelligent way to respond to attacks. Birmingham, UK: Packt Publishing.
&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class="footdef"&gt;&lt;sup&gt;&lt;a id="fn.3" class="footnum" href="https://necromuralist.github.io/posts/tcp-dump-notes/#fnr.3"&gt;3&lt;/a&gt;&lt;/sup&gt; &lt;div class="footpara"&gt;&lt;p class="footpara"&gt;
Beltrame, J. (2017). Penetration testing bootcamp : quickly get up and running with pentesting techniques. Birmingham, UK: Packt Publishing.
&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class="footdef"&gt;&lt;sup&gt;&lt;a id="fn.4" class="footnum" href="https://necromuralist.github.io/posts/tcp-dump-notes/#fnr.4"&gt;4&lt;/a&gt;&lt;/sup&gt; &lt;div class="footpara"&gt;&lt;p class="footpara"&gt;
McPhee. &amp;amp; Beltrame, J. (2016). Penetration testing with Raspberry Pi : learn the art of building a low-cost, portable hacking arsenal using Raspberry Pi 3 and Kali Linux 2. Birmingham, UK: Packt Publishing.
&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class="footdef"&gt;&lt;sup&gt;&lt;a id="fn.5" class="footnum" href="https://necromuralist.github.io/posts/tcp-dump-notes/#fnr.5"&gt;5&lt;/a&gt;&lt;/sup&gt; &lt;div class="footpara"&gt;&lt;p class="footpara"&gt;
Baxter, J., Orzach, Y. &amp;amp; Mishra, C. (2017). Wireshark revealed : essential skills for IT professionals : get up and running with Wireshark to analyze your network effectively. Birmingham, UK: Packt Publishing.
&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;


&lt;/div&gt;
&lt;/div&gt;</description><category>networking</category><category>notes</category><guid>https://necromuralist.github.io/posts/tcp-dump-notes/</guid><pubDate>Wed, 09 May 2018 21:54:56 GMT</pubDate></item><item><title>Tuning a TCP Connection</title><link>https://necromuralist.github.io/posts/201209tuning-tcp-connection/</link><dc:creator>Cloistered Monkey</dc:creator><description>&lt;div id="table-of-contents"&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id="text-table-of-contents"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/posts/201209tuning-tcp-connection/#orge0fc671"&gt;TCP Background&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/posts/201209tuning-tcp-connection/#org2526353"&gt;The TCP Congestion Window&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/posts/201209tuning-tcp-connection/#org96264e6"&gt;Optimal Buffer Size&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/posts/201209tuning-tcp-connection/#orgea63b1c"&gt;Changing the Buffer Size&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/posts/201209tuning-tcp-connection/#orgb56f2b7"&gt;Picking a Buffer Size&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/posts/201209tuning-tcp-connection/#org280b23c"&gt;The Maximum Throughput&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/posts/201209tuning-tcp-connection/#orgbeea5b7"&gt;Bandwidth Delay Product&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/posts/201209tuning-tcp-connection/#org5d9424d"&gt;Iperf Tuning&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/posts/201209tuning-tcp-connection/#org2be62a6"&gt;Iperf Warnings&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/posts/201209tuning-tcp-connection/#org5fa3711"&gt;Parallel Streams&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/posts/201209tuning-tcp-connection/#org1155d94"&gt;Maximum Transmission Unit (MTU)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
I wrote this a long time ago so I don't remember the source or really the intent. I think it was about trying to maximize the throughput when running iperf over TCP.
&lt;/p&gt;

&lt;div id="outline-container-orge0fc671" class="outline-2"&gt;
&lt;h2 id="orge0fc671"&gt;TCP Background&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orge0fc671"&gt;
&lt;/div&gt;
&lt;div id="outline-container-org2526353" class="outline-3"&gt;
&lt;h3 id="org2526353"&gt;The TCP Congestion Window&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org2526353"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;Larger window implies higher throughput&lt;/li&gt;
&lt;li&gt;The max allowed is based on the buffer space the kernel allocates for
each socket&lt;/li&gt;
&lt;li&gt;Each socket has a default buffer size&lt;/li&gt;
&lt;li&gt;Sender and receiver can both adjust the size&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org96264e6" class="outline-3"&gt;
&lt;h3 id="org96264e6"&gt;Optimal Buffer Size&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org96264e6"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;Too small - Sender will be throttled
&lt;ul class="org-ul"&gt;
&lt;li&gt;More likely if the Sender is faster than the receiver&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Too big - Receiver might be overloaded and packets will be dropped
&lt;ul class="org-ul"&gt;
&lt;li&gt;If the receiver has lots of memory, less likely to happen&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgea63b1c" class="outline-2"&gt;
&lt;h2 id="orgea63b1c"&gt;Changing the Buffer Size&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgea63b1c"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;TCP chooses the smaller of both sides of the transaction.&lt;/li&gt;
&lt;li&gt;Set the receiver high and let the sender negotiate&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgb56f2b7" class="outline-2"&gt;
&lt;h2 id="orgb56f2b7"&gt;Picking a Buffer Size&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgb56f2b7"&gt;
&lt;/div&gt;
&lt;div id="outline-container-org280b23c" class="outline-3"&gt;
&lt;h3 id="org280b23c"&gt;The Maximum Throughput&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org280b23c"&gt;
&lt;p&gt;
If the network isn't congested the throughput is characterized by TCP buffer size and network latency.
&lt;/p&gt;

\begin{equation*} max \; throughput \gets \frac{buffer \; size}{latency}
\end{equation*}
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgbeea5b7" class="outline-3"&gt;
&lt;h3 id="orgbeea5b7"&gt;Bandwidth Delay Product&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgbeea5b7"&gt;
&lt;p&gt;
This is a rule of thumb to calculate the optimal buffer size.
&lt;/p&gt;

\begin{equation*} bdp \gets bottleneck \; bandwidth \times round \; trip
\; time \end{equation*}

&lt;ul class="org-ul"&gt;
&lt;li&gt;Get the &lt;b&gt;rtt&lt;/b&gt; from &lt;b&gt;ping&lt;/b&gt;.&lt;/li&gt;
&lt;li&gt;Get &lt;b&gt;bottleneck bandwidth&lt;/b&gt; from the theoretical maximum rate of the slowest link.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org5d9424d" class="outline-2"&gt;
&lt;h2 id="org5d9424d"&gt;Iperf Tuning&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org5d9424d"&gt;
&lt;/div&gt;
&lt;div id="outline-container-org2be62a6" class="outline-3"&gt;
&lt;h3 id="org2be62a6"&gt;Iperf Warnings&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org2be62a6"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;Iperf can set the buffer size up to a point – but the OS sets the
upper limit on window sizes.&lt;/li&gt;
&lt;li&gt;If the request is too high, iperf will use the maximum allowed and gives a warning.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org5fa3711" class="outline-3"&gt;
&lt;h3 id="org5fa3711"&gt;Parallel Streams&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org5fa3711"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;Iperf lets you run multiple parallel sessions using the -P flag.&lt;/li&gt;

&lt;li&gt;If the aggregate (SUM) is greater than a single stream, this is an indication that something is wrong – most likely one of:
&lt;ul class="org-ul"&gt;
&lt;li&gt;The TCP window is too small&lt;/li&gt;
&lt;li&gt;The OS implementation has bugs&lt;/li&gt;
&lt;li&gt;The network has problems&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org1155d94" class="outline-3"&gt;
&lt;h3 id="org1155d94"&gt;Maximum Transmission Unit (MTU)&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org1155d94"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;the most effective way to set it is if both hosts support Path MTU Discovery and set it themselves.&lt;/li&gt;
&lt;li&gt;iperf's -m flag displays what mss is being used&lt;/li&gt;
&lt;li&gt;&lt;b&gt;mss&lt;/b&gt;: &lt;i&gt;Maximum Segment Size&lt;/i&gt; – the maximum TCP segment size&lt;/li&gt;
&lt;/ul&gt;

\begin{equation*} mss \gets MTU - protocol \; headers \end{equation*}

&lt;ul class="org-ul"&gt;
&lt;li&gt;Using -m is mainly to watch for the warning that the node lacks path mtu discovery&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>networking</category><category>optimization</category><guid>https://necromuralist.github.io/posts/201209tuning-tcp-connection/</guid><pubDate>Mon, 10 Sep 2012 06:51:00 GMT</pubDate></item></channel></rss>